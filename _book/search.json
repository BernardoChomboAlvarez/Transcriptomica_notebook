[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Transcriptómica",
    "section": "",
    "text": "Generalidades\nBienvenidx al curso de Transcriptómica en el semestre 2025-2. Aquí encontrarás un resumen con todos los códigos y comandos relevantes vistos en clase. Cada uno de los capítulos se actualizarán después de cada clase. El contenido es una guía para la realización de sus tareas y el proyecto final.\nDatos de profesor y del ayudante:\nHorario del curso:\nAsesorías o dudas puntuales\nSi el alumno tiene dudas puntuales, por favor ingrese al siguiente link: Agendar reunión",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Transcriptómica</span>"
    ]
  },
  {
    "objectID": "index.html#temario",
    "href": "index.html#temario",
    "title": "Transcriptómica",
    "section": "Temario",
    "text": "Temario",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Transcriptómica</span>"
    ]
  },
  {
    "objectID": "index.html#criterios-de-evaluación",
    "href": "index.html#criterios-de-evaluación",
    "title": "Transcriptómica",
    "section": "Criterios de evaluación",
    "text": "Criterios de evaluación",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Transcriptómica</span>"
    ]
  },
  {
    "objectID": "index.html#calendario-de-actividades",
    "href": "index.html#calendario-de-actividades",
    "title": "Transcriptómica",
    "section": "Calendario de Actividades",
    "text": "Calendario de Actividades",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Transcriptómica</span>"
    ]
  },
  {
    "objectID": "index.html#desempeño",
    "href": "index.html#desempeño",
    "title": "Transcriptómica",
    "section": "Desempeño",
    "text": "Desempeño",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Transcriptómica</span>"
    ]
  },
  {
    "objectID": "index.html#referencias",
    "href": "index.html#referencias",
    "title": "Transcriptómica",
    "section": "Referencias",
    "text": "Referencias\n\nRapaport F, Khanin R, Liang Y, Pirun M, Krek A, Zumbo P, Mason CE, Socci ND, Betel D. Comprehensive evaluation of differential gene expression analysis methods for RNA-seq data. Genome Biol. 2013; 14(9):R95\nJänes J, Hu F, Lewin A, Turro E. A comparative study of RNA-seq analysis strategies. Brief Bioinform. 2015; 16(6):932-40\nConesa A, Madrigal P, Tarazona S, Gomez-Cabrero D, Cervera A, McPherson A, Szcześniak MW, Gaffney DJ, Elo LL, Zhang X, Mortazavi A. A survey of best practices for RNA-seq data analysis. Genome Biol. 2016; 17:13.\nZiegenhain C, Vieth B, Parekh S, Reinius B, Guillaumet-Adkins A, Smets M, Leonhardt H, Heyn H, Hellmann I, Enard W. Comparative Analysis of Single-Cell RNA Sequencing Methods. Mol Cell. 2017; 65(4):631-643.\nStark R, Grzelak M, Hadfield J. RNA sequencing: the teenage years. Nat Rev Genet. 2019; 20(11):631-656",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Transcriptómica</span>"
    ]
  },
  {
    "objectID": "chapters/Clase3_AlineamientoDeSecuencias1.html",
    "href": "chapters/Clase3_AlineamientoDeSecuencias1.html",
    "title": "Alineamiento de secuencias I",
    "section": "",
    "text": "1. Analizar y limpiar archivos .fastq con FASTQC\nEl software FASTQC sirve para analizar y limpiar archivos .fastq de acuerdo a su calidad. Se puede descargar directamente desde la página https://www.bioinformatics.babraham.ac.uk/projects/fastqc/ o bien si eres usuario de Linux lo puedes hacer de la siguiente forma:\n## Direct installation\nsudo apt -y install fastqc\n\n## Conda installation\nconda update conda\nconda create --name fastqc_env\nconda activate fastqc_env\nconda install -c bioconda fastqc\nPara entender qué es lo que FASTQC está haciendo, es necesario entender la sintaxis de los archivos .fastq",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Alineamiento de Secuencias I</span>"
    ]
  },
  {
    "objectID": "chapters/Clase3_AlineamientoDeSecuencias1.html#analizar-y-limpiar-archivos-.fastq-con-fastqc",
    "href": "chapters/Clase3_AlineamientoDeSecuencias1.html#analizar-y-limpiar-archivos-.fastq-con-fastqc",
    "title": "Alineamiento de secuencias I",
    "section": "",
    "text": "1.1 Nomenclatura\nLos archivos se nombran con el nombre de la muestra y el número del nombre de la muestra (int) : samplename_S1_L001_R1_001.fastq.gz\ndonde:\n\nsamplename: nombre de la muestra\nS1: índice de la muestra\nL001: número del carril del secuenciador\nR1: la lectura (read). Cuando son archivos paired-end debe de haber al menos un R1 y R2\n001: EL último segmento siempre es 001\n.gz: los archivos siempre se van a guardar en el formato GNU zip\n\n\n\n1.2 Formato\nCada entrada en un archivo de FASTQ consiste en las siguientes 4 líneas:\n\nIdentificador de la secuencia (empezando con @)\nSecuencia\nLínea identificadora del score de calidad (+)\nScore de calidad. Estos están codificados en formato Phred +33, donde usan caracteres ASCII para representar los valores numéricos de los scores de calidad.\n\n\n@SIM:1:FCX:1:15:6329:1045 1:N:0:2\nTCGCACTCAACGCCCTGCATATGACAAGACAGAATC\n+\n&lt;&gt;;##=&gt;&lt;9=AAAAAAAAAA9#:&lt;#&lt;;&lt;&lt;&lt;????#=\n\nEl quality score o score de calidad expresa la probabilidad de un error. Dada A, el quality score de A, Q(A), expresa la probabilidad de que A no sea cierta, P(~A), de acuerdo a la siguiente relación:\n\\[\nQ(A) = 10log10(P(~A))\n\\]\nSi se calculan los quality scores podemos obtener la siguiente relación:\n\n\n\nQuality Score, Q(A)\nError probability, P(~A)\n\n\n\n\n10\n0.1\n\n\n20\n0.01\n\n\n30\n0.001\n\n\n\nQuality Score encoding\nPara entender la 4ta línea es necesario conocer los valores ASCII y sus equivalencias\n\n\n\nSymbol\nASCII Code\nQ-Score\n\n\n\n\n!\n33\n0\n\n\n”\n34\n1\n\n\n#\n35\n2\n\n\n$\n36\n3\n\n\n%\n37\n4\n\n\n&\n38\n5\n\n\n’\n39\n6\n\n\n(\n40\n7\n\n\n)\n41\n8\n\n\n*\n42\n9\n\n\n+\n43\n10\n\n\n,\n44\n11\n\n\n-\n45\n12\n\n\n.\n46\n13\n\n\n/\n47\n14\n\n\n0\n48\n15\n\n\n1\n49\n16\n\n\n2\n50\n17\n\n\n3\n51\n18\n\n\n4\n52\n19\n\n\n5\n53\n20\n\n\n6\n54\n21\n\n\n7\n55\n22\n\n\n8\n56\n23\n\n\n9\n57\n24\n\n\n:\n58\n25\n\n\n;\n59\n26\n\n\n&lt;\n60\n27\n\n\n=\n61\n28\n\n\n&gt;\n62\n29\n\n\n?\n63\n30\n\n\n@\n64\n31\n\n\nA\n65\n32\n\n\nB\n66\n33\n\n\nC\n67\n34\n\n\nD\n68\n35\n\n\nE\n69\n36\n\n\nF\n70\n37\n\n\nG\n71\n38\n\n\nH\n72\n39\n\n\nI\n73\n40\n\n\n\n\n\n1.3 Propósito\nEl propósito general y más simplificado de FASTQC se puede resumir en los siguientes 4 puntos:\n\nImportar datos de archivos .fastq (aunque también puede aceptar archivos de alineamiento .bam y .sam)\nRápida identificación de posibles problemas de la secuenciación\nGráficos y tablas que resumen los datos de forma accesible\nExportación de los resultados en formato HTML\n\nEn el caso de que se haga con raw data:\n\nIdentificar errores de la secuenciación\nIdentificar secuencias contaminantes sobre representadas\nEntendimiento de la complejidad de la librería (contaminación de rRNA, duplicaciones)\nRepresentación adecuada del organismo por el porcentaje de %GC reportado (si hay sobre representación de genes, puede no ser útil)\n\nPara más información relacionada con casos puntuales como los errores de secuenciación, consultar las referencias.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Alineamiento de Secuencias I</span>"
    ]
  },
  {
    "objectID": "chapters/Clase3_AlineamientoDeSecuencias1.html#alineamiento-con-genomas-conocidos",
    "href": "chapters/Clase3_AlineamientoDeSecuencias1.html#alineamiento-con-genomas-conocidos",
    "title": "Alineamiento de secuencias I",
    "section": "2. Alineamiento con genomas conocidos",
    "text": "2. Alineamiento con genomas conocidos\n\n\n2.1 Bowtie2\nIdeal para lecturas de al menos 50 bp (&lt; 50 deben de usar bowtie1). EL default es un alineamiento end-to-end y funciona mejor cuando el ya se cortaron por cuestiones\nde calidad y para remover secuencias de adaptadores. De no haber limpiado previamente los reads se recomienda hacer soft-clipping el cual ignora las porciones a los exremos de las reads y le asigna una penalización menor a las bases no alineadas.\nManual bowtie2\n\n2.1.1 Construcción de un index\n\nbowtie2-build &lt;path_to_reference_genome.fa&gt; &lt;prefix_to_name_indexes&gt;\n\n\n\n2.1.2 Alineamiento\nArgumentos importantes para el alineamiento con Bowtie2:\n\n-p: number of cores\n-q: reads are in FASTQ format\n--local: local alignment feature to perform soft-clipping\n-x: /path/to/genome_indices_directory\n-U: /path/to/FASTQ_file\n-S: /path/to/output/SAM_file\n-N: number of mismatches allowed in a seed\n-L: length of the seed substrings to align\n-k: searches for the k best valid alignments\n-m: maixmum number of alignments\n--best: best alignments only\n--strata: alignments in the best stratum only\n\n\n## Create bowtie2 directory results\nmkdir ~/transcriptomica/results/bowtie2\n\n## Run bowtie2\nbowtie2 -p 10 -q -N 0 -L 18 -m 10 --best --strata \\\n-x ~/path/to/bowtie_indexes/mm10 \\\n-U ~/path/to/FASTQ_file.fastq.gz \\\n-S ~/path/to/output/SAM_file.sam\n\n\n\n\n\n2.2 hisat2\nUn alineamiento con hisat2 requiere de un archivo .fasta y de un archivo .gtf o .gff3\nManual hisat2\n\n2.2.1 Construcción de un index\nPuede crear un index de genomas de cualquier tamaño.\n\n## Build index\nhisat2-build [options]* &lt;reference_in&gt; &lt;ht2_base&gt;\n\n\n\n2.2.2 Alineamiento\nArgumentos importantes para el alineamiento con Bowtie2:\n\n-q: print the wall-clock time required to load the index files and align the reads.\n-5: trim 5 bases from 3’ (right) end of each read before alignment.\n-3: trim 3 bases from 3’ (right) end of each read before alignment.\n-p: number of cores\n-k: search for the k distinct primary alignments for each read.\n-t: reads (,,) are in FASTQ format\n-u: align the first u reads or read pairs from the input\n--phred33: input qualities are ASCII chars equal to the Phred quality plus 33\n--tmo: report only those alignments within known transcripts\n--no-mixed: y default, when hisat2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.\n--no-discordant: by default, hisat2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (–fr/–rf/–ff, -I, -X). This option disables that behavior.\n--rna-strandness: specify strand-specific information: the default is unstranded. For single-end reads, use F or R.\n--no-unal: suppress SAM records for reads that failed to align.\n--remove-chrname: remove ‘chr’ from reference names in alignment\n--add-chrname: add ‘chr’ to reference names in alignment\n-x: the basename of the index for the reference genome.\n-1: &lt;m1&gt;\n-2: &lt;m2&gt;\n-U: comma-separated list of files containing unpaired reads to be aligned\n-S: /path/to/output/SAM_file\n\n\n## Build index\nhisat2 -x ~/path/to/index_genes/ -1 &lt;read1&gt; -2 &lt;read2&gt; -p 10 \\\n-S ~/path/to/output/SAM_file.sam --mto --phred33",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Alineamiento de Secuencias I</span>"
    ]
  },
  {
    "objectID": "chapters/Clase3_AlineamientoDeSecuencias1.html#referencias",
    "href": "chapters/Clase3_AlineamientoDeSecuencias1.html#referencias",
    "title": "Alineamiento de secuencias I",
    "section": "Referencias",
    "text": "Referencias\n\nhttps://help.basespace.illumina.com/files-used-by-basespace/fastq-files\nhttps://help.basespace.illumina.com/files-used-by-basespace/fastq-files\nhttps://hbctraining.github.io/Training-modules/planning_successful_rnaseq/lessons/\nQC_raw_data.html#:\\~:text=The%20FASTQ%20file%20format%20is,begins%20with%\n20a%20header%20line\nhttps://hbctraining.github.io/Intro-to-ChIPseq-flipped/lessons/04_alignment_using_bowtie2.html\nhttps://daehwankimlab.github.io/hisat2/manual/\nhttps://hbctraining.github.io/Intro-to-rnaseq-hpc-O2/lessons/03_alignment.html",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Alineamiento de Secuencias I</span>"
    ]
  },
  {
    "objectID": "chapters/Clase4_AlineamientoDeSecuencias2.html",
    "href": "chapters/Clase4_AlineamientoDeSecuencias2.html",
    "title": "Alineamiento de secuencias II",
    "section": "",
    "text": "1. Alineamiento con genomas no anotados\nEn la clase pasada se vieron los alineamientos con genomas anotados, en esta se verá cómo alinear datos de secuenciación de RNA-seq con genomas no anotados.\nPor lo general se usan estos alineadores cuando NO se considera splicing y se está trabajando con datos de ChIP-seq o microRNA-seq",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Alineamiento de Secuencias II</span>"
    ]
  },
  {
    "objectID": "chapters/Clase3_AlineamientoDeSecuencias1.html#alineamiento-con-genomas-anotados",
    "href": "chapters/Clase3_AlineamientoDeSecuencias1.html#alineamiento-con-genomas-anotados",
    "title": "Alineamiento de secuencias I",
    "section": "2. Alineamiento con genomas anotados",
    "text": "2. Alineamiento con genomas anotados\n\nPor lo general se emplean estos alineadores cuando se considera splicing.\n\n2.1 STAR (Spliced Transcripts Alignment to a Reference)\nRequiere del genoma de referencia en formato fasta y de un archivo de anotación .gtf.\nManual STAR\n\n2.1.1 Construcción de un index\nArgumentos básicos para la construcción de un index con STAR:\n\n--runThreadN: number of cores\n--runMode: genomeGenerate mode\n--genomeDir: /path/to/store/genome_indices\n--genomeFastaFiles: /path/to/FASTA_file\n--sjdbGTFfile: /path/to/GTF_file\n--sjdbOverhang: readlength -1\n\n\n## Create index wiht STAR\nSTAR --runThreadN 6 \\\n--runMode genomeGenerate \\\n--genomeDir chr1_hg38_index \\\n--genomeFastaFiles /n/groups/hbctraining/intro_rnaseq_hpc/reference_data_ensembl38/Homo_sapiens.GRCh38.dna.chromosome.1.fa \\\n--sjdbGTFfile /n/groups/hbctraining/intro_rnaseq_hpc/reference_data_ensembl38/Homo_sapiens.GRCh38.92.gtf \\\n--sjdbOverhang 99\n\n\n\n2.1.2 Alineamiento\nArgumentos importantes para el alineamiento con STAR:\n\n--runThreadN: number of cores\n--readFilesIn: /path/to/FASTQ_file\n--genomeDir: /path/to/genome_indices\n--outFileNamePrefix: prefix for all output files\n--outSAMtype: output filetype (SAM default)\n--outSAMunmapped: what to do with unmapped reads\n--outFilterMultimapNmax: maximum number of multiple alignments (default 10)\n\n\n## Run STAR\nSTAR --genomeDir /n/groups/hbctraining/intro_rnaseq_hpc/reference_data_ensembl38/ensembl38_STAR_index/ \\\n--runThreadN 6 \\\n--readFilesIn Mov10_oe_1.subset.fq \\\n--outFileNamePrefix ../results/STAR/Mov10_oe_1_ \\\n--outSAMtype BAM SortedByCoordinate \\\n--outSAMunmapped Within \\\n--outSAMattributes Standard \n\n\n\n\n\n2.2 hisat2\nUn alineamiento con hisat2 requiere de un archivo .fasta y de un archivo .gtf o .gff3\nManual hisat2\n\n2.2.1 Construcción de un index\nPuede crear un index de genomas de cualquier tamaño.\n\n## Build index\nhisat2-build [options]* &lt;reference_in&gt; &lt;ht2_base&gt;\n\n\n\n2.2.2 Alineamiento\nArgumentos importantes para el alineamiento con Bowtie2:\n\n-q: print the wall-clock time required to load the index files and align the reads.\n-5: trim n bases from 5’ (left) end of each read before alignment.\n-3: trim n bases from 3’ (right) end of each read before alignment.\n-p: number of cores\n-k: search for the k distinct primary alignments for each read.\n-t: reads (,,) are in FASTQ format\n-u: align the first u reads or read pairs from the input\n--phred33: input qualities are ASCII chars equal to the Phred quality plus 33\n--tmo: report only those alignments within known transcripts\n--no-mixed: y default, when hisat2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.\n--no-discordant: by default, hisat2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (–fr/–rf/–ff, -I, -X). This option disables that behavior.\n--rna-strandness: specify stra-5nd-specific information: the default is unstranded. For single-end reads, use F or R.\n--no-unal: suppress SAM records for reads that failed to align.\n--remove-chrname: remove ‘chr’ from reference names in alignment\n--add-chrname: add ‘chr’ to reference names in alignment\n-x: the basename of the index for the reference genome.\n-1: &lt;m1&gt;\n-2: &lt;m2&gt;\n-U: comma-separated list of files containing unpaired reads to be aligned\n-S: /path/to/output/SAM_file\n\n\n## Build index\nhisat2 -x ~/path/to/index_genes/ -1 &lt;read1&gt; -2 &lt;read2&gt; -p 10 \\\n-S ~/path/to/output/SAM_file.sam --mto --phred33",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Alineamiento de Secuencias I</span>"
    ]
  },
  {
    "objectID": "chapters/Clase4_AlineamientoDeSecuencias2.html#alineamiento-con-genomas-no-anotados",
    "href": "chapters/Clase4_AlineamientoDeSecuencias2.html#alineamiento-con-genomas-no-anotados",
    "title": "Alineamiento de secuencias II",
    "section": "",
    "text": "1.1 Diferencias entre Bowtie y Bowtie2\nExisten pocas pero putnuales referencias entyre alineadores para genomas no anotados y se espera que se usen de acuerdo a lo más conveniente.\n\n1.1.1 Compatibilidad con lecturas cortas y largas\n\nBowtie: Diseñado para alinear lecturas cortas (25-50bp).\nBowtie2: Diseñado para alinear lecturas cortas y largas (&gt; 50 bp).\n\n\n\n1.1.2 Alineación de lecturas emparejadas\n\nBowtie: Limitado para manejar paired-end reads.\nBowtie2: Permite manejar paired-end reads.\n\n\n\n1.1.3 Capacidad de permitir desajustes e indels\n\nBowtie: No maneja bien los indels.\nBowtie2: Maneja bien los indels, lo que lo hace mejor para lecturas más largas y variantes estructurales.\n\n\n\n1.1.4 Rendimiento\n\nBowtie: Muy rápido para short-reads con pocas variaciones, pero menos preciso para escenarios más complejos.\nBowtie2: Más lento que Bowtie para lecturas cortas, pero más versátil y eficiente para lecturas largas.\n\n\n\n1.1.5 Sensibilidad\n\nBowtie: Trade-off rápidez vs. sensibilidad.\nBowtie2: Menos sensible debido a la capacidad de manejar alineaciones locales y globales.\n\n\n\n1.1.6 Modos de alineación\n\nBowtie: Sólo permite alineamiento global.\nBowtie2: Alineamiento local y global.\n\n\n\n1.1.7 Consumo de recursos\n\nBowtie: Más ligero en términos de memoria, eficiente para genomas pequeños.\nBowtie2: Requiere más memoria que Bowtie.\n\n\n\n1.1.8 Tecnologías de secuenciación\n\nBowtie: Principalmente diseñado para lecturas de Illumina.\nBowtie2: Compatible con NGS modernas como PacBio y Oxford Nanopore.\n\nEn general comparten casi los mismos parámetros, excluyendo aquellos que involucran las diferencias de alineamiento (global, local).\nManual de bowtie\n\n\n\n1.2 Bowtie2\nIdeal para lecturas de al menos 50 bp (&lt; 50 deben de usar bowtie1). EL default es un alineamiento end-to-end y funciona mejor cuando el ya se cortaron por cuestiones\nde calidad y para remover secuencias de adaptadores. De no haber limpiado previamente los reads se recomienda hacer soft-clipping el cual ignora las porciones a los exremos de las reads y le asigna una penalización menor a las bases no alineadas.\nManual bowtie2\n\n1.2.1 Construcción de un index\n\nbowtie2-build &lt;path_to_reference_genome.fa&gt; &lt;prefix_to_name_indexes&gt;\n\n\n\n1.2.2 Alineamiento\nArgumentos importantes para el alineamiento con Bowtie2:\n\n-p: number of cores\n-q: reads are in FASTQ format\n--local: local alignment feature to perform soft-clipping\n-x: /path/to/genome_indices_directory\n-U: /path/to/FASTQ_file\n-S: /path/to/output/SAM_file\n-N: number of mismatches allowed in a seed\n-L: length of the seed substrings to align\n-k: searches for the k best valid alignments\n-m: maixmum number of alignments\n--best: best alignments only\n--strata: alignments in the best stratum only\n\n\n## Create bowtie2 directory results\nmkdir ~/transcriptomica/results/bowtie2\n\n## Run bowtie2\nbowtie2 -p 10 -q -N 0 -L 18 -m 10 --best --strata \\\n-x ~/path/to/bowtie_indexes/mm10 \\\n-U ~/path/to/FASTQ_file.fastq.gz \\\n-S ~/path/to/output/SAM_file.sam",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Alineamiento de Secuencias II</span>"
    ]
  },
  {
    "objectID": "chapters/Clase4_AlineamientoDeSecuencias2.html#referencias",
    "href": "chapters/Clase4_AlineamientoDeSecuencias2.html#referencias",
    "title": "Alineamiento de secuencias II",
    "section": "Referencias",
    "text": "Referencias\n\nhttps://hbctraining.github.io/Intro-to-ChIPseq-flipped/lessons/04_alignment_using_bowtie2.html",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Alineamiento de Secuencias II</span>"
    ]
  },
  {
    "objectID": "chapters/Clase5_TransformacionDeFormatos.html",
    "href": "chapters/Clase5_TransformacionDeFormatos.html",
    "title": "Transformación de formatos | feature counts | creación de pileups",
    "section": "",
    "text": "1. Transformar formatos\nPara transformar formatos se emplean las herramientas de SamTools. Para ello hay que entender el contenido de una entrada de un archivo .sam (Sequence Alignment/Map)\nLas Flags en un archivo .sam son importantes porque permiten identificar si las lecturas están correctamente alineadas, si son parte de un experimento paired-end, la posición de la cadena, identificar lecturas duplicadas o de baja calidad, entre otras.\nLas flags se interpretan como una suma de potencias de 2, donde cada bit tiene un significado específico.\nSiguiendo el ejemplo mostrado en la imagen, la flag es 147, en binario es 10010011, si lo descomponemos en bits activados, se ve de la siguiente forma:",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Transformación de Formatos</span>"
    ]
  },
  {
    "objectID": "chapters/Clase5_TransformacionDeFormatos.html#transformar-formatos",
    "href": "chapters/Clase5_TransformacionDeFormatos.html#transformar-formatos",
    "title": "Transformación de formatos | feature counts | creación de pileups",
    "section": "",
    "text": "Valor del bit\nSignificado\n\n\n\n\n1\nLa lectura está emparejada (paired-end).\n\n\n2\nAmbas lecturas del par están alineadas.\n\n\n4\nLa lectura no está alineada.\n\n\n8\nSu pareja no está alineada.\n\n\n16\nLa lectura está en la cadena inversa.\n\n\n32\nSu pareja está en la cadena inversa.\n\n\n64\nEs la primera lectura del par.\n\n\n128\nEs la segunda lectura del par.\n\n\n256\nAlineación secundaria.\n\n\n512\nLectura duplicada.\n\n\n1024\nLectura no pasa filtros de calidad.\n\n\n\n\n\n\n\n\n\n\n\n\n\nBit\nValue\nSignificance\nState\n\n\n\n\n1\n1\nLectura emparejada (paired-end).\nActivated\n\n\n2\n2\nAmbas lecturas del par están alineadas.\nActivated\n\n\n4\n4\nLa lectura no está alineada.\nNot activated\n\n\n8\n8\nLectura par no está alineada.\nNot activated\n\n\n16\n16\nLectura en la cadena inversa (reverse strand).\nActivated\n\n\n32\n32\nSu pareja está en la cadena inversa.\nActivated\n\n\n64\n64\nEs la primera lectura del par.\nNot activated\n\n\n128\n128\nEs la segunda lectura del par.\nActivated\n\n\n256\n256\nAlineación secundaria.\nNot activated\n\n\n512\n512\nLectura duplicada.\nNot activated\n\n\n1024\n1024\nLectura no pasa filtros de calidad.\nNot activated\n\n\n\n\n1.1 Samtools\nEs necesario convertir el formato .sam a .bam debido a que el formato .sam es muy pesado y ocupa muchos recursos de memoria.\nManual Samtools\n\nsamtools view: prints all alignments in the specified input alignment file to standard output\nsamtools sort: Sort alignments by leftmost coordinates\nsamtools index: Index coordinate-sorted BGZIP-compressed SAM, BAM or CRAM files for fast random access.\n\n\n## Run Samtools view\n## Output result in BAM format and filter alignments &gt;= 10 in quality score\nsamtools view -bSq 10 ${FILE}.sam | \\\nsamtools sort --threads 5 -T ${FILE} -o ${FILE}.bam\n\n## Run Samtools index\nsamtools index ${FILE}.bam\n\n## Run Samtools view again\nsamtools view -c ${FILE}.bam\n\n## Remove .sam file\nrm ${FILE}.sam\n\n\n\n1.2 Deeptools\nTambién se puede usar el software Deeptools. Este es una suite de python desarrollado particularmente para análisis de secuenciación masiva como ChIP-seq, RNA-seq o MNase-seq.\nManual Deeptools\n\n1.2.1 Instalación\nConda\n\nconda install -c conda-forge -c bioconda deeptools\n\n## DO NOT RUN\nCONDA_SUBDIR=osx-64 conda create -c conda-forge -c bioconda -n deeptools deeptools\n\nPip\n\npip install deeptools\n\n## Or specific version\npip install deeptools==3.5.3\n\n## Or development version\ngit clone https://github.com/deeptools/deepTools.git\ncd deepTools\npip install .\n\n\n\n1.2.2 bamCoverage\nThe output in bigwig format can be visualized in thre UCSC Genome Browser\n\n--filterRNAstrand: option assumes the sequencing library generated from ILLUMINA dUTP/NSR/NNSR methods (forward, reverse).\n-p: number of cores\n-b: path/to/BAM_file.bam\n-o: /path/to/output_file\n-of: output format (bigwig, bedgraph)\n-bs: size of the bins, in bases, for the output of the bigwig/bedgraph file. (Default: 50)\n--blackListFileName: a BED or GTF file containing regions that should be excluded from all analyses.\n--normalizeUsing: possible choices: RPKM, CPM, BPM, RPGC, None\n--skipNAs: this parameter determines if non-covered regions (regions without overlapping reads) in a BAM file should be skipped.\n--ignoreDuplicates: if set, reads that have the same orientation and start position will be considered only once. If reads are paired, the mate’s position also has to coincide to ignore a read.\n--samFlagInclude: include reads based on the SAM flag.\n\nbamCoverage Manual\nStandard RNA-seq\n\nbamCoverage -b a.bam -o a.bw\n\nStranded single-end library\n\n## Forward strand\nbamCoverage -b a.bam -o a.fwd.bw --samFlagExclude 16\n\n## Reverse strand\nbamCoverage -b a.bam -o a.rev.bw --samFlagInclude 16\n\nTranscripts from the forward strand\n\n## Include reads that are 2nd in a pair (128)\n## Include reads that are mapped to the reverse strand (16)\nsamtools view -b -f 128 -F 16 a.bam &gt; a.fwd1.bam\n\n## Exclude maps that are mapped to the reverse strand (16) and\n## first in a pair (64): 80\nsamtools view -b -f 80 a.bam &gt; a.fwd2.bam\n\n## Combine the temporary files\nsamtools merge -f fwd.bam a.fwd1.bam a.fwd2.bam\n\n## index the filtered BAM file\nsamtools index fwd.bam\n\n## run bamCoverage\nbamCoverage -b fwd.bam -o a.fwd.bigWig\n\n## remove the temporary file\nrm a.fwd*.bam\n\nTranscripts from the reverse strand\n\n## Include reads that are 2nd in a pair (128)\n## and are second in a pair (16): 144\nsamtools view -b -f 144 a.bam &gt; a.rev1.bam\n\n## Include maps that are mfirst in a pair (64), but\n## exclude those ones that map to the reverse strand (16)\nsamtools view -b -f 64 -F 16 a.bam &gt; a.rev2.bam\n\n## Combine the temporary files\nsamtools merge -f rev.bam a.rev1.bam a.rev2.bam\n\n## index the filtered BAM file\nsamtools index rev.bam\n\n## run bamCoverage\nbamCoverage -b rev.bam -o a.rev.bw\n\n## remove the temporary file\nrm a.rev*.bam\n\n\n\n\n1.3 Feature Counts\nSe pude usar featureCounts vía línea de comandos o con R.\n\n1.3.1 Instalación\nSe pude descargar desde la SourceForge: https://sourceforge.net/projects/subread/files/subread-2.0.8/. Para windows se puede ddescargar le instalador o en Linux se necesita compilar usando make\n\ntar zxvf subread-1.x.x.tar.gz\nmake -f Makefile.Linux\n\nPara la instalación de Rsubread en R se necesita tener instalado BioConductor e instalar Rsubread vía BiocManager.\n\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(\"Rsubread\")\n\nRsubread Manual\n\n\n1.3.2 Gene Counts\nCommand Line\nSummarize a single-end read dataset using 5 thread\n\nfeatureCounts -T 5 -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_SE.sam\n\nSummarize a BAM format dataset\n\nfeatureCounts -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_SE.bam\n\nSummarize multiple datasets at the same time\n\nfeatureCounts -t exon -g gene_id -a annotation.gtf -o counts.txt library1.bam library2.bam library3.bam\n\nPerform strand-specific read counting (use ‘-s 2’ if reversely stranded)\n\nfeatureCounts -s 1 -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_SE.bam\n\nSummarize paired-end reads and count fragments (instead of reads)\n\nfeatureCounts -p --countReadPairs -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_PE.bam\n\nSummarize multiple paired-end datasets\n\nfeatureCounts -p --countReadPairs -t exon -g gene_id -a annotation.gtf -o counts.txt library1.bam library2.bam library3.bam\n\nCount the fragments that have fragment length between 50bp and 600bp only\n\nfeatureCounts -p --countReadPairs -P -d 50 -D 600 -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_PE.bam\n\nCount those fragments that have both ends mapped only\n\nfeatureCounts -p --countReadPairs -B -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_PE.bam\n\nExclude chimeric fragments from fragment counting\n\nfeatureCounts -p --countReadPairs -C -t exon -g gene_id -a annotation.gtf -o counts.txt mapping_results_PE.bam\n\nR\nSummarize a single-end read dataset using 5 thread\n\nlibrary(Rsubread)\nfeatureCounts(\n  files = \"mapping_results_SE.sam\",\n  annot.ext = \"annotation.gtf\",\n  isGTFAnnotationFile = TRUE,\n  GTF.featureType = \"exon\",\n  GTF.attrType = \"gene_id\",\n  nthreads = 5,\n  strandSpecific = 0,\n  isPairedEnd = FALSE\n)\n\nSummarize a BAM format dataset\n\nfeatureCounts(\n  files = \"mapping_results_SE.bam\",\n  annot.ext = \"annotation.gtf\",\n  isGTFAnnotationFile = TRUE,\n  GTF.featureType = \"exon\",\n  GTF.attrType = \"gene_id\",\n  nthreads = 1,\n  strandSpecific = 0,\n  isPairedEnd = FALSE\n)\n\nSummarize multiple datasets at the same time\n\nfeatureCounts(\n  files = c(\"library1.bam\", \"library2.bam\", \"library3.bam\"),\n  annot.ext = \"annotation.gtf\",\n  isGTFAnnotationFile = TRUE,\n  GTF.featureType = \"exon\",\n  GTF.attrType = \"gene_id\",\n  nthreads = 1,\n  strandSpecific = 0,\n  isPairedEnd = FALSE\n)\n\nPerform strand-specific read counting (use ‘-s 2’ if reversely stranded)\n\nfeatureCounts(\n  files = \"mapping_results_SE.bam\",\n  annot.ext = \"annotation.gtf\",\n  isGTFAnnotationFile = TRUE,\n  GTF.featureType = \"exon\",\n  GTF.attrType = \"gene_id\",\n  nthreads = 1,\n  strandSpecific = 1,\n  isPairedEnd = FALSE\n)\n\nSummarize paired-end reads and count fragments (instead of reads)\n\nfeatureCounts(\n  files = \"mapping_results_PE.bam\",\n  annot.ext = \"annotation.gtf\",\n  isGTFAnnotationFile = TRUE,\n  GTF.featureType = \"exon\",\n  GTF.attrType = \"gene_id\",\n  nthreads = 1,\n  strandSpecific = 0,\n  isPairedEnd = TRUE\n)\n\nSummarize multiple paired-end datasets\n\nfeatureCounts(\n  files = c(\"library1.bam\", \"library2.bam\", \"library3.bam\"),\n  annot.ext = \"annotation.gtf\",\n  isGTFAnnotationFile = TRUE,\n  GTF.featureType = \"exon\",\n  GTF.attrType = \"gene_id\",\n  nthreads = 1,\n  strandSpecific = 0,\n  isPairedEnd = TRUE\n)\n\nCount the fragments that have fragment length between 50bp and 600bp only\n\nfeatureCounts(\n  files = \"mapping_results_PE.bam\",\n  annot.ext = \"annotation.gtf\",\n  isGTFAnnotationFile = TRUE,\n  GTF.featureType = \"exon\",\n  GTF.attrType = \"gene_id\",\n  nthreads = 1,\n  strandSpecific = 0,\n  isPairedEnd = TRUE,\n  minFragLength = 50,\n  maxFragLength = 600\n)\n\nCount those fragments that have both ends mapped only\n\nfeatureCounts(\n  files = \"mapping_results_PE.bam\",\n  annot.ext = \"annotation.gtf\",\n  isGTFAnnotationFile = TRUE,\n  GTF.featureType = \"exon\",\n  GTF.attrType = \"gene_id\",\n  nthreads = 1,\n  strandSpecific = 0,\n  isPairedEnd = TRUE,\n  requireBothEndsMapped = TRUE\n)\n\nExclude chimeric fragments from fragment counting\n\nfeatureCounts(\n  files = \"mapping_results_PE.bam\",\n  annot.ext = \"annotation.gtf\",\n  isGTFAnnotationFile = TRUE,\n  GTF.featureType = \"exon\",\n  GTF.attrType = \"gene_id\",\n  nthreads = 1,\n  strandSpecific = 0,\n  isPairedEnd = TRUE,\n  countChimericFragments = FALSE\n)\n\nAlternativamente se puede emplear htseq-count para los cuales el manual se puede encontrar en el siguiente link: Manual htseq-count.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Transformación de Formatos</span>"
    ]
  },
  {
    "objectID": "chapters/Clase5_TransformacionDeFormatos.html#referencias",
    "href": "chapters/Clase5_TransformacionDeFormatos.html#referencias",
    "title": "Transformación de formatos | feature counts | creación de pileups",
    "section": "Referencias",
    "text": "Referencias\n\nhttps://htseq.readthedocs.io/en/release_0.11.1/count.html\nhttps://bioconductor.org/packages/release/bioc/manuals/Rsubread/man/Rsubread.pdf",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Transformación de Formatos</span>"
    ]
  },
  {
    "objectID": "chapters/Clase7_AnalisisDeExpresionDiferencial.html",
    "href": "chapters/Clase7_AnalisisDeExpresionDiferencial.html",
    "title": "Análisis de Expresión Diferencial I",
    "section": "",
    "text": "1. Motivación\nEl análisis de expresión diferencial identifica genes o moléculas con cambios significativos en sus niveles de expresión bajo diferentes condiciones, como enfermedades o tratamientos. Es crucial para comprender mecanismos biológicos, descubrir biomarcadores, desarrollar terapias dirigidas y avanzar en la medicina personalizada. En bioinformática, el DEA permite procesar y analizar grandes volúmenes de datos de tecnologías como RNA-Seq o microarrays, ayudando a identificar patrones clave en redes biológicas. Su importancia radica en generar conocimiento sobre enfermedades, guiar investigaciones y acelerar el desarrollo de herramientas diagnósticas y terapéuticas.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Análisis de Expresión Diferencial</span>"
    ]
  },
  {
    "objectID": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#motivación",
    "href": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#motivación",
    "title": "Análisis de Expresión Diferencial I",
    "section": "",
    "text": "1.1 Setup de datos\nVamos a usar este set de datos: https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE63310&format=file\n\n## Download data\nurl &lt;- \"https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE63310&format=file\"\nutils::download.file(url = url,\n                     destfile = \"GSE63310.tar\",\n                     mode = \"wb\")\nutils::untar(tarfile = \"GSE63310.tar\",\n             exdir = file.path(tempdir(),\"GSE63310\"))\n\n## Unzip files\nfiles &lt;- c(\"GSM1545535_10_6_5_11.txt\", \"GSM1545536_9_6_5_11.txt\", \"GSM1545538_purep53.txt\",\n  \"GSM1545539_JMS8-2.txt\", \"GSM1545540_JMS8-3.txt\", \"GSM1545541_JMS8-4.txt\",\n  \"GSM1545542_JMS8-5.txt\", \"GSM1545544_JMS9-P7c.txt\", \"GSM1545545_JMS9-P8c.txt\")\nfor(i in paste(files, \".gz\", sep=\"\"))\n  R.utils::gunzip(file.path(tempdir(),\"GSE63310/\",i), overwrite=TRUE)",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Análisis de Expresión Diferencial</span>"
    ]
  },
  {
    "objectID": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#edger-limma-glimma",
    "href": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#edger-limma-glimma",
    "title": "Análisis de Expresión Diferencial I",
    "section": "2. EdgeR / Limma / Glimma",
    "text": "2. EdgeR / Limma / Glimma\nEdgeR es una librería de R que se usa para realizar análisis de expresión diferencial de genes provenientes de datos de RNA-seq. Esta librería emplea métodos estadísticos para experimentos multigrupo basados en modelos lineares generalizados (generalized linear models: glms) los cuales son eficientes para experimentos multifactoriales independientemente de su complejidad. También implementa métodos Bayesianos que permiten la estimación de la variación biológica genética-específica, incluso para experimentos con los mínimos niveles de replicación biológica.\n\nDocumentación (EdgeR)\n\n\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\", quiet = TRUE)\n\nif (!require(edgeR, quietly = TRUE))\n    BiocManager::install(\"edgeR\",quiet = TRUE)\n\nLimma es una librería de R que fue creada para el ánalisis de expresión diferencial para datos provenientes de microarreglos. Usa principalmente modelos lineales para experimentos multigrupos.\n\nDocumentación (limma)\n\n\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\", quiet = TRUE)\n\nif (!require(limma, quietly = TRUE))\n    BiocManager::install(\"limma\",quiet = TRUE)\n\nGlimma es una librería de R que permite crear gráficos interactivos provenientes de las librerías edgeR y limma.\n\nDocumentación (glimma)\n\n\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\", quiet = TRUE)\n\nif (!require(Glimma, quietly = TRUE))\n    BiocManager::install(\"Glimma\",quiet = TRUE)\n\n\n2.1 Load libraries\n\nsuppressPackageStartupMessages(library(limma))\nsuppressPackageStartupMessages(library(Glimma))\nsuppressPackageStartupMessages(library(edgeR))\nsuppressPackageStartupMessages(library(Mus.musculus))\n\n\n\n2.2 Read files\n\nx &lt;- readDGE(file.path(tempdir(),\"GSE63310/\",files),\n             columns = c(1,3))\nclass(x)\n\n## [1] \"DGEList\"\n## attr(,\"package\")\n## [1] \"edgeR\"\n\ndim(x)\n\n## [1] 27179     9\n\n\n\n2.2.1 Reorganize information\n\n## Assign sample type and sample names\nsamplenames &lt;- substring(colnames(x),67)\nsamplenames\n\n## [1] \"10_6_5_11\" \"9_6_5_11\"  \"purep53\"   \"JMS8-2\"    \"JMS8-3\"    \"JMS8-4\"   \n## [7] \"JMS8-5\"    \"JMS9-P7c\"  \"JMS9-P8c\"\n\ncolnames(x) &lt;- samplenames\ngroup &lt;- as.factor(c(\"LP\", \"ML\", \"Basal\", \"Basal\", \"ML\", \"LP\",\n                     \"Basal\", \"ML\", \"LP\"))\nx$samples$group &lt;- group\nlane &lt;- as.factor(rep(c(\"L004\",\"L006\",\"L008\"), c(3,4,2)))\nx$samples$lane &lt;- lane\nx$samples\n\n\n  \n\n\n\n\n\n2.2.2 Add gene names\n\ngenes &lt;- AnnotationDbi::select(Mus.musculus,\n                        keys = rownames(x),\n                        columns = c(\"SYMBOL\",\"TXCHROM\"),\n                        keytype = \"ENTREZID\")\n\n## Remove duplicates\ngenes &lt;- genes[!duplicated(genes$ENTREZID),]\nhead(genes)\n\n\n  \n\n\n## Add genes\nx$genes &lt;- genes\nx\n\n## An object of class \"DGEList\"\n## $samples\n##                                                                                           files\n## 10_6_5_11 C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545535_10_6_5_11.txt\n## 9_6_5_11   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545536_9_6_5_11.txt\n## purep53     C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545538_purep53.txt\n## JMS8-2       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545539_JMS8-2.txt\n## JMS8-3       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545540_JMS8-3.txt\n## JMS8-4       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545541_JMS8-4.txt\n## JMS8-5       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545542_JMS8-5.txt\n## JMS9-P7c   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545544_JMS9-P7c.txt\n## JMS9-P8c   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545545_JMS9-P8c.txt\n##           group lib.size norm.factors lane\n## 10_6_5_11    LP 32863052            1 L004\n## 9_6_5_11     ML 35335491            1 L004\n## purep53   Basal 57160817            1 L004\n## JMS8-2    Basal 51368625            1 L006\n## JMS8-3       ML 75795034            1 L006\n## JMS8-4       LP 60517657            1 L006\n## JMS8-5    Basal 55086324            1 L006\n## JMS9-P7c     ML 21311068            1 L008\n## JMS9-P8c     LP 19958838            1 L008\n## \n## $counts\n##            Samples\n## Tags        10_6_5_11 9_6_5_11 purep53 JMS8-2 JMS8-3 JMS8-4 JMS8-5 JMS9-P7c\n##   497097            1        2     342    526      3      3    535        2\n##   100503874         0        0       5      6      0      0      5        0\n##   100038431         0        0       0      0      0      0      1        0\n##   19888             0        1       0      0     17      2      0        1\n##   20671             1        1      76     40     33     14     98       18\n##            Samples\n## Tags        JMS9-P8c\n##   497097           0\n##   100503874        0\n##   100038431        0\n##   19888            0\n##   20671            8\n## 27174 more rows ...\n## \n## $genes\n##    ENTREZID  SYMBOL TXCHROM\n## 1    497097    Xkr4    chr1\n## 2 100503874 Gm19938    &lt;NA&gt;\n## 3 100038431 Gm10568    &lt;NA&gt;\n## 4     19888     Rp1    chr1\n## 5     20671   Sox17    chr1\n## 27174 more rows ...\n\n\n\n\n\n2.3 Data preprocessing\n\n## counts per million\ncpm.obj &lt;- cpm(x)\n\n## log counts per million transformation\nlcpm.obj &lt;- cpm(x, log = TRUE)\n\n## Mean and median\nL &lt;- mean(x$samples$lib.size) * 1e-6\nM &lt;- median(x$samples$lib.size) * 1e-6\nc(L, M)\n\n## [1] 45.48855 51.36862\n\n## The average library ssize es about 45.5 million and the minimum\n## log-CPM should be log2(2/45.5) = -4.51 which means that\n## a count of 0 maps to a log-CPM value of -4.51\nsummary(lcpm.obj)\n\n##    10_6_5_11          9_6_5_11          purep53             JMS8-2       \n##  Min.   :-4.5074   Min.   :-4.5074   Min.   :-4.50743   Min.   :-4.5074  \n##  1st Qu.:-4.5074   1st Qu.:-4.5074   1st Qu.:-4.50743   1st Qu.:-4.5074  \n##  Median :-0.6847   Median :-0.3589   Median :-0.09513   Median :-0.0901  \n##  Mean   : 0.1714   Mean   : 0.3312   Mean   : 0.43559   Mean   : 0.4089  \n##  3rd Qu.: 4.2913   3rd Qu.: 4.5601   3rd Qu.: 4.60081   3rd Qu.: 4.5475  \n##  Max.   :14.7632   Max.   :13.4952   Max.   :12.95700   Max.   :12.8513  \n##      JMS8-3            JMS8-4            JMS8-5            JMS9-P7c      \n##  Min.   :-4.5074   Min.   :-4.5074   Min.   :-4.50743   Min.   :-4.5074  \n##  1st Qu.:-4.5074   1st Qu.:-4.5074   1st Qu.:-4.50743   1st Qu.:-4.5074  \n##  Median :-0.4281   Median :-0.4064   Median :-0.07152   Median :-0.1704  \n##  Mean   : 0.3225   Mean   : 0.2529   Mean   : 0.40428   Mean   : 0.3708  \n##  3rd Qu.: 4.5772   3rd Qu.: 4.3199   3rd Qu.: 4.42513   3rd Qu.: 4.6031  \n##  Max.   :12.9578   Max.   :14.8520   Max.   :13.19491   Max.   :12.9413  \n##     JMS9-P8c      \n##  Min.   :-4.5074  \n##  1st Qu.:-4.5074  \n##  Median :-0.3300  \n##  Mean   : 0.2749  \n##  3rd Qu.: 4.4355  \n##  Max.   :14.0102\n\n\n\n\n2.4 Remove genes that are lowly expressed\n\n## Remove all the genes that have 0 counts across the nine samples\ntable(rowSums(x$counts==0)==9)\n\n## \n## FALSE  TRUE \n## 22026  5153\n\n## Filter by expression\nkeep.exprs &lt;- filterByExpr(x,group = group)\nx &lt;- x[keep.exprs,,keep.lib.sizes=FALSE]\ndim(x)\n\n## [1] 16624     9\n\n\n\n\n2.5 Normalize gene expression\nSe necesita normalizar debido a que los datos de RNA-Seq contienen sesgos técnicos y biológicos que pueden distorsionar los resultados si no se corrigen. Las razones principales para normalizar son: diferencias de profundidad de secuenciación, diferencias en la composición génica, comparabilidad entre muestras, impacto de la longitud de los genes, preparación para métodos estadísticos.\nMétodos comunes de normalización:\n\nTMM (Trimmed Mean of M-values): Corrige la profundidad de secuenciación y la composición génica.\nRPKM/FPKM (Reads/Fragments Per Kilobase Million): Normaliza por la longitud del gen y el tamaño total de las muestras.\nTPM (Transcripts Per Million): Similar a RPKM, pero mejora la comparabilidad entre muestras.\nDESeq2/EdgeR Scaling Factors: Ajustan los conteos para análisis estadísticos robustos.\n\n\n## Normalize\nx &lt;- calcNormFactors(x,method = \"TMM\") # Trimmed mean of M-values\nx$samples$norm.factors\n\n## [1] 0.8943956 1.0250186 1.0459005 1.0458455 1.0162707 0.9217132 0.9961959\n## [8] 1.0861026 0.9839203\n\n\nComparación entre normalizar o no\n\nx2 &lt;- x\nx2$samples$norm.factors &lt;- 1\nx2$counts[,1] &lt;- ceiling(x2$counts[,1]*0.05)\nx2$counts[,2] &lt;- x2$counts[,2]*5\n\nVisualización:\n\ncol &lt;- c(\"#A6CEE3\",\"#1F78B4\",\"#B2DF8A\",\"#33A02C\",\"#FB9A99\",\"#E31A1C\",\"#FDBF6F\",\"#FF7F00\",\"#CAB2D6\")\npar(mfrow=c(1,2))\nlcpm &lt;- cpm(x2, log=TRUE)\nboxplot(lcpm, las=2, col=col, main=\"\")\ntitle(main=\"A. Example: Unnormalised data\",ylab=\"Log-cpm\")\nx2 &lt;- calcNormFactors(x2)  \nx2$samples$norm.factors\n\n## [1] 0.05770899 6.08287835 1.22023972 1.16478991 1.19661094 1.04659233 1.15048074\n## [8] 1.25431164 1.10901983\n\nlcpm &lt;- cpm(x2, log=TRUE)\nboxplot(lcpm, las=2, col=col, main=\"\")\ntitle(main=\"B. Example: Normalised data\",ylab=\"Log-cpm\")\n\n\n\n\n\n\n\n\n\n\n2.6 Unsupervised clustering of samples\n\nUsar una MultiDimensional Scaling plot (MDS): esta muestra la similitudes y disimilitudes entre las muestras con algoritmo no supervisado. La primera dimensión representa el fold-change que mejor separa a las muestras y que explica la mayor proporción de la variancia de los datos. Aquí nos podemos dar cuenta si se deben de hacer algunas correcciones del batch.\n\n\nlcpm &lt;- cpm(x, log=TRUE)\n\n## Define colors\npar(mfrow=c(1,2))\ncol.group &lt;- group\nlevels(col.group) &lt;-  RColorBrewer::brewer.pal(nlevels(col.group), \"Set1\")\ncol.group &lt;- as.character(col.group)\n\n## Define colors\ncol.lane &lt;- lane\nlevels(col.lane) &lt;-  RColorBrewer::brewer.pal(nlevels(col.lane), \"Set2\")\ncol.lane &lt;- as.character(col.lane)\n\n## Plot MDS\nplotMDS(lcpm, labels=group, col=col.group)\ntitle(main=\"A. Sample groups\")\nplotMDS(lcpm, labels=lane, col=col.lane, dim=c(3,4))\ntitle(main=\"B. Sequencing lanes\")\n\n\n\n\n\n\n\n\n\n\n2.7 Differential expression analysis\n\n2.7.1 Create a matrix\nGenes que están expresados en diferentes niveles. Los modelos lineales se ajustan a los datos bajo la asunción de que los datos siguen una distribución normal (lo cual no es cierto porque siguen una distribución binomial negativa o una de poisson).\nEste diseño experimental quita el intercepto del primer factor group pero un intercepto permanece con el segundo factor lane. Es esencial entender cómo interpretar los coeficientes en el modelo.\n\ndesign &lt;- model.matrix(~0 + group + lane)\ncolnames(design) &lt;- gsub(\"group\",\"\",colnames(design))\ndesign\n\n##   Basal LP ML laneL006 laneL008\n## 1     0  1  0        0        0\n## 2     0  0  1        0        0\n## 3     1  0  0        0        0\n## 4     1  0  0        1        0\n## 5     0  0  1        1        0\n## 6     0  1  0        1        0\n## 7     1  0  0        1        0\n## 8     0  0  1        0        1\n## 9     0  1  0        0        1\n## attr(,\"assign\")\n## [1] 1 1 1 2 2\n## attr(,\"contrasts\")\n## attr(,\"contrasts\")$group\n## [1] \"contr.treatment\"\n## \n## attr(,\"contrasts\")$lane\n## [1] \"contr.treatment\"\n\ncontr.matrix &lt;- makeContrasts(\n   BasalvsLP = Basal-LP, \n   BasalvsML = Basal - ML, \n   LPvsML = LP - ML, \n   levels = colnames(design))\ncontr.matrix\n\n##           Contrasts\n## Levels     BasalvsLP BasalvsML LPvsML\n##   Basal            1         1      0\n##   LP              -1         0      1\n##   ML               0        -1     -1\n##   laneL006         0         0      0\n##   laneL008         0         0      0\n\n\n\n\n2.7.2 Removing heteroscedascity from count data\nPara los datos de RNA-seq la varianza no es independiente de la media sin importar si los datos sufren una transformación logarítmica o no. Los modelos que asumen una distribución binomial negativa asumen una relación cuadrática media-varianza.\nEl plot de voom ilustra la relación media-varianza. Este plot muestra una trend que decrece entre la media y la varianza como resultado de la combinación de la varianza técnica en los experimentos de secuenciación y de la varianza biológica entre las réplicas de las muestras de las diferentes poblaciones celulares.\nExperimentos con una variación biológica alta resultan en tendencias más planas.\nExperimentos con una variación biológica baja reusltan en tendencias decrecientes pronunciadas.\n\npar(mfrow=c(1,2))\nv &lt;- voom(x, design, plot=TRUE)\nv\n\n## An object of class \"EList\"\n## $genes\n##   ENTREZID SYMBOL TXCHROM\n## 1   497097   Xkr4    chr1\n## 5    20671  Sox17    chr1\n## 6    27395 Mrpl15    chr1\n## 7    18777 Lypla1    chr1\n## 9    21399  Tcea1    chr1\n## 16619 more rows ...\n## \n## $targets\n##                                                                                           files\n## 10_6_5_11 C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545535_10_6_5_11.txt\n## 9_6_5_11   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545536_9_6_5_11.txt\n## purep53     C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545538_purep53.txt\n## JMS8-2       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545539_JMS8-2.txt\n## JMS8-3       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545540_JMS8-3.txt\n## JMS8-4       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545541_JMS8-4.txt\n## JMS8-5       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545542_JMS8-5.txt\n## JMS9-P7c   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545544_JMS9-P7c.txt\n## JMS9-P8c   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\Rtmpq6WJ4c/GSE63310//GSM1545545_JMS9-P8c.txt\n##           group lib.size norm.factors lane\n## 10_6_5_11    LP 29387429    0.8943956 L004\n## 9_6_5_11     ML 36212498    1.0250186 L004\n## purep53   Basal 59771061    1.0459005 L004\n## JMS8-2    Basal 53711278    1.0458455 L006\n## JMS8-3       ML 77015912    1.0162707 L006\n## JMS8-4       LP 55769890    0.9217132 L006\n## JMS8-5    Basal 54863512    0.9961959 L006\n## JMS9-P7c     ML 23139691    1.0861026 L008\n## JMS9-P8c     LP 19634459    0.9839203 L008\n## \n## $E\n##         Samples\n## Tags     10_6_5_11  9_6_5_11   purep53     JMS8-2    JMS8-3    JMS8-4    JMS8-5\n##   497097 -4.292165 -3.856488 2.5185849  3.2931366 -4.459730 -3.994060 3.2869677\n##   20671  -4.292165 -4.593453 0.3560126 -0.4073032 -1.200995 -1.943434 0.8442767\n##   27395   3.876089  4.413107 4.5170045  4.5617546  4.344401  3.786363 3.8990635\n##   18777   4.708774  5.571872 5.3964008  5.1623650  5.649355  5.081611 5.0602470\n##   21399   4.785541  4.754537 5.3703795  5.1220551  4.869586  4.943840 5.1384776\n##         Samples\n## Tags       JMS9-P7c  JMS9-P8c\n##   497097 -3.2103696 -5.295316\n##   20671  -0.3228444 -1.207853\n##   27395   4.3396075  4.124644\n##   18777   5.7513694  5.142436\n##   21399   5.0308985  4.979644\n## 16619 more rows ...\n## \n## $weights\n##           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]\n## [1,]  1.079413  1.332986 19.826915 20.273253  1.993686  1.395853 20.494977\n## [2,]  1.170357  1.456380  4.804866  8.660025  3.612508  2.626870  8.760149\n## [3,] 20.219073 25.573792 30.434759 28.528310 31.352260 25.743247 28.722497\n## [4,] 26.947557 32.505933 33.583128 33.232125 34.231754 32.354158 33.334340\n## [5,] 26.610864 28.501638 33.645479 33.206374 33.573492 31.996623 33.308490\n##           [,8]      [,9]\n## [1,]  1.107780  1.079413\n## [2,]  3.211473  2.541942\n## [3,] 21.200072 16.657930\n## [4,] 30.348630 24.259801\n## [5,] 25.171513 23.573305\n## 16619 more rows ...\n## \n## $design\n##   Basal LP ML laneL006 laneL008\n## 1     0  1  0        0        0\n## 2     0  0  1        0        0\n## 3     1  0  0        0        0\n## 4     1  0  0        1        0\n## 5     0  0  1        1        0\n## 6     0  1  0        1        0\n## 7     1  0  0        1        0\n## 8     0  0  1        0        1\n## 9     0  1  0        0        1\n## attr(,\"assign\")\n## [1] 1 1 1 2 2\n## attr(,\"contrasts\")\n## attr(,\"contrasts\")$group\n## [1] \"contr.treatment\"\n## \n## attr(,\"contrasts\")$lane\n## [1] \"contr.treatment\"\n\nvfit &lt;- lmFit(v, design)\nvfit &lt;- contrasts.fit(vfit, contrasts=contr.matrix)\nefit &lt;- eBayes(vfit)\nplotSA(efit, main=\"Final model: Mean-variance trend\")\n\n\n\n\n\n\n\n\n\n\n2.7.1 Examining the number of DE genes\nLa significancia está dada por el threshold al p-value ajustado (5%). Aunque a veces se emplea el valor del log-foldchange como threshold.\n\n## Using adjusted p-value\nsummary(decideTests(efit))\n\n##        BasalvsLP BasalvsML LPvsML\n## Down        4648      4927   3135\n## NotSig      7113      7026  10972\n## Up          4863      4671   2517\n\n## Using log-foldchange\ntfit &lt;- treat(vfit, lfc=1)\ndt &lt;- decideTests(tfit)\nsummary(dt)\n\n##        BasalvsLP BasalvsML LPvsML\n## Down        1632      1777    224\n## NotSig     12976     12790  16210\n## Up          2016      2057    190\n\n## Extract the DEG's shared between both conditions\nde.common &lt;- which(dt[,1]!=0 & dt[,2]!=0)\nlength(de.common)\n\n## [1] 2784\n\nvennDiagram(dt[,1:2], circle.col=c(\"turquoise\", \"salmon\"))\n\n\n\n\n\n\n\n\n\n\n2.7.1 Examining individual DE genes from top to bottom\nExtraer los resultados más significativos.\n\n## CHeck ?topTreat for more details\nbasal.vs.lp &lt;- topTreat(tfit, coef=1, n=Inf)\n\nbasal.vs.ml &lt;- topTreat(tfit, coef=2, n=Inf)\nhead(basal.vs.lp)\n\n\n  \n\n\nhead(basal.vs.ml)\n\n\n  \n\n\n\n\n\n2.7.1 Useful graphical representations of differential expression results\nMD plot\n\nplotMD(tfit, column=1, status=dt[,1], main=colnames(tfit)[1], \n       xlim=c(-8,13))\n\n\n\n\n\n\n\n\nVolcano plot\n\npar(mfrow=c(1,2))\n\nplotVolcano(df = basal.vs.lp,\n            pval_col = \"P.Value\",\n            lfc_col = \"logFC\",\n            adjpval_col = \"adj.P.Val\",\n            plot_title = \"Basal vs. LP\")\n\n## [1] TRUE\n\nplotVolcano(df = basal.vs.ml,\n            pval_col = \"P.Value\",\n            lfc_col = \"logFC\",\n            adjpval_col = \"adj.P.Val\",\n            plot_title = \"Basal vs. LP\")\n\n\n\n\n\n\n\n\n## [1] TRUE\n\n\nHeatmap\n\n## Basal vs. LP heatmap\nbasal.vs.lp.topgenes &lt;- basal.vs.lp$ENTREZID[1:100]\ni &lt;- which(v$genes$ENTREZID %in% basal.vs.lp.topgenes)\n\nhmap.palette &lt;- colorRampPalette(c(\"red\", \"white\", \"blue\"))\npheatmap::pheatmap(lcpm[i,],\n                   scale = \"row\",\n                   cluster_rows = TRUE,\n                   labels_row = v$genes$SYMBOL[i],\n                   labels_col = group,\n                   color = hmap.palette(100),\n                   main = \"Basal vs. LP\")\n\n\n\n\n\n\n\n## Basal vs. ML heatmap\nbasal.vs.ml.topgenes &lt;- basal.vs.ml$ENTREZID[1:100]\ni &lt;- which(v$genes$ENTREZID %in% basal.vs.ml.topgenes)\n\nhmap.palette &lt;- colorRampPalette(c(\"red\", \"white\", \"blue\"))\npheatmap::pheatmap(lcpm[i,],\n                   scale = \"row\",\n                   cluster_rows = TRUE,\n                   labels_row = v$genes$SYMBOL[i],\n                   labels_col = group,\n                   color = hmap.palette(100),\n                   main = \"Basal vs. ML\")",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Análisis de Expresión Diferencial</span>"
    ]
  },
  {
    "objectID": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#deseq2",
    "href": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#deseq2",
    "title": "Análisis de Expresión Diferencial I",
    "section": "3. DESeq2",
    "text": "3. DESeq2\nDESeq2 es ubna librería de R que sirve para realizar experimentos de expresión diferencial. Su input es la matriz de conteos crudos resultantes de un experimento de secuenciación de RNA-seq.\n\nDocumentación (DESeq2)\nDOI: https://doi.org/10.1186/s13059-014-0550-8\n\n\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\", quiet = TRUE)\n\nif (!require(DESeq2, quietly = TRUE))\n    BiocManager::install(\"DESeq2\",quiet = TRUE)\n\n\n3.1 Load libraries\n\nsuppressPackageStartupMessages(library(DESeq2))\n\n\n\n3.2 Read files\n\nfiles &lt;- file.path(tempdir(),\"GSE63310/\",files)\n\n## Load all the files into a list of dataframes\ncounts.list &lt;- lapply(files, function(file) {\n    data &lt;- read.delim(file, header = TRUE, stringsAsFactors = FALSE)\n    data[, c(\"EntrezID\", \"Count\")]\n})\nnames(counts.list) &lt;- substring(basename(files), 12, nchar(basename(files)) - 4)\n\n## Merge the dataframes into a single counts matrix\ncounts.mtx &lt;- Reduce(function(x, y) {\n    merge(x, y, by = \"EntrezID\", all = TRUE)\n}, counts.list)\nrownames(counts.mtx) &lt;- counts.mtx$EntrezID\ncounts.mtx &lt;- counts.mtx[, -1]\ncolnames(counts.mtx) &lt;- names(counts.list)\n\n\n3.2.1 Create metadata\nEs neceario que se cree un dataframe con los metadatos del experimento. Aquí una muestra de las condiciones experimentales.\n\nGroup: condiciones experimentales\nLane: se refiere al batch (lote, ronda de secuenciación)\nlib.size: se trata del total de counts registrados\nnorm.factors: factores de normalización\n\n\n## Create metadata\ngroup &lt;- as.factor(c(\"LP\", \"ML\", \"Basal\", \"Basal\", \"ML\", \"LP\",\n                     \"Basal\", \"ML\", \"LP\"))\nlane &lt;- as.factor(rep(c(\"L004\",\"L006\",\"L008\"), c(3,4,2)))\ndds_metadata &lt;- data.frame(group = group,\n                           lib.size = colSums(counts.mtx),\n                           norm.factors = 1,\n                           lane = lane)\ndds_metadata\n\n\n  \n\n\n\n\n\n\n3.3 Create DESeq2 object\nSe puede importar de diferentes fuentes. Una de ellas es usando archivos de la abundancia de transcritos con la librería tximport, otra es con una matriz de conteos, otra con archivos de conteos de htseq-count y la última de un objeto de SummarizedExperiment.\n\n## Create DESeq2 object\ndds &lt;- DESeqDataSetFromMatrix(countData = counts.mtx,\n                              colData = dds_metadata,\n                              design = ~ group + lane)\ndds\n\n## class: DESeqDataSet \n## dim: 27179 9 \n## metadata(1): version\n## assays(1): counts\n## rownames(27179): 11287 11298 ... 100862405 100862406\n## rowData names(0):\n## colnames(9): 10_6_5_11 9_6_5_11 ... JMS9-P7c JMS9-P8c\n## colData names(4): group lib.size norm.factors lane\n\n\n\n\n3.4 Data pre-filter\nSe necesita realizar un pre filtrado de los genes que tuvieron un conteo bajo. Por un lado se reduce el tamaño que ocupa en la memoria el objeto dds e incrementar la velocidad de modelado de los conteos. Como valores standard se ocupa lo siguiente:\n\nrows con un mínimo de 10 counts.\nUsar el smallest group size el cual es igual al número de muestras.\n\n\n## We have 9 samples\nsmallestGroupSize &lt;- 9\nkeep &lt;- rowSums(counts(dds) &gt;= 10) &gt;= smallestGroupSize\ndds &lt;- dds[keep,]\ndds\n\n## class: DESeqDataSet \n## dim: 13274 9 \n## metadata(1): version\n## assays(1): counts\n## rownames(13274): 11302 11303 ... 100862307 100862400\n## rowData names(0):\n## colnames(9): 10_6_5_11 9_6_5_11 ... JMS9-P7c JMS9-P8c\n## colData names(4): group lib.size norm.factors lane\n\n\n\n3.4.1 Refactor metadata\n\n## Put the reference in the first position of the levels\ndds$group &lt;- factor(dds$group, levels = c(\"Basal\",\"LP\",\"ML\"))\n\n## Or just relevel them specifying the reference\ndds$group &lt;- relevel(dds$group, ref = \"Basal\")\n\nAdicionalmente se pueden colapsar todas las réplicas en columnas individuales con la función DESeq2::collapseReplicates() ESTO SOLO PARA RÉPLICAS TÉCNICAS, NO PARA BIOLÓGICAS (una réplica técnica implica múltiples corridas de secuenciación de la misma librería).\n\n\n3.4.2 Add gene names\n\ngenes &lt;- AnnotationDbi::select(Mus.musculus,\n                        keys = rownames(dds),\n                        columns = c(\"SYMBOL\",\"TXCHROM\"),\n                        keytype = \"ENTREZID\")\n\n## Remove duplicates\ngenes &lt;- genes[!duplicated(genes$ENTREZID),]\nrownames(genes) &lt;- genes$ENTREZID\n\n## Add genes\nrowData(dds) &lt;- genes\n\n\n\n\n3.5 Differential Expression Analysis\nAsí de simple.\n\ndds &lt;- DESeq(dds)\nres &lt;- results(dds)\nres\n\n## log2 fold change (MLE): lane L008 vs L004 \n## Wald test p-value: lane L008 vs L004 \n## DataFrame with 13274 rows and 6 columns\n##            baseMean log2FoldChange     lfcSE      stat    pvalue      padj\n##           &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\n## 11302      524.8568      0.2025970  0.427536  0.473871  0.635592  0.914339\n## 11303     5688.7471      0.1132199  0.312441  0.362372  0.717074  0.935875\n## 11304       43.6222      0.1260263  0.510059  0.247082  0.804845  0.960693\n## 11305     3258.0083     -0.0949987  0.168277 -0.564539  0.572387  0.893517\n## 11306     1850.6776      0.0372121  0.181120  0.205455  0.837216  0.967711\n## ...             ...            ...       ...       ...       ...       ...\n## 100862251 1084.2679       0.157915  0.199627  0.791051  0.428914  0.842320\n## 100862257 3711.2564      -0.180482  0.157793 -1.143787  0.252712  0.729788\n## 100862258   67.0328      -0.518082  0.381632 -1.357545  0.174608  0.646332\n## 100862307   51.7442       0.321677  0.394997  0.814379  0.415428  0.834233\n## 100862400   88.7577       0.359888  0.497736  0.723049  0.469650  0.857534\n\n\nSi quisiéramos extraer los genes diferencialmente expresados filtrando por el adjusted p-value entonces se le debe de agregar el parámetro alpha = &lt;float&gt; a la función results(). Por ejemplo, si queremos los DEG’s que son menores o iguales a 0.05 entonces se ve así:\n\nres05 &lt;- results(dds, alpha = 0.05)\nsummary(res05)\n\n## \n## out of 13274 with nonzero total read count\n## adjusted p-value &lt; 0.05\n## LFC &gt; 0 (up)       : 112, 0.84%\n## LFC &lt; 0 (down)     : 196, 1.5%\n## outliers [1]       : 0, 0%\n## low counts [2]     : 0, 0%\n## (mean count &lt; 17)\n## [1] see 'cooksCutoff' argument of ?results\n## [2] see 'independentFiltering' argument of ?results\n\nsum(res05$padj &lt; 0.05, na.rm=TRUE)\n\n## [1] 308\n\n\nAdemás, se pueden revisar las comparaciones hechas:\n\nresultsNames(dds)\n\n## [1] \"Intercept\"         \"group_LP_vs_Basal\" \"group_ML_vs_Basal\"\n## [4] \"lane_L006_vs_L004\" \"lane_L008_vs_L004\"\n\n\n\n3.5.1 Exploring results\nPara la visualización se pueden “encoger” los resultados de acuerdo al efecto del tamaño. El estimador por default es apeglm el cual estima con una tendencia al 0, lo que promueve la estabilidad de los estimados en los cuales hay una variabilidad alta o tamaños de muestra pequeños.\n\nresLFC.LPBas &lt;- lfcShrink(dds,coef = 2,type = \"apeglm\")\nresLFC.MLBas &lt;- lfcShrink(dds,coef = 3,type = \"apeglm\")\n\nMA-plot\n\nplotMA(res05, ylim=c(-2,2))\n\n\n\n\n\n\n\nplotMA(resLFC.LPBas, ylim=c(-2,2))\n\n\n\n\n\n\n\nplotMA(resLFC.MLBas, ylim=c(-2,2))\n\n\n\n\n\n\n\n\nGet dispersion factors\nAquí se obtienen los factores de dispersión que es similar a lo que hace la función voom en EdgeR. Aquí se usa la función para Variance stabilizing transformations (vst) la cual transforma a los datos en una escala log2 la cual ha sido normalizada con respecto al tamaño de la librería u otros factores de normalización. La finalidad de esto es eliminar la dependencia de la varianza en la media (si se trabaja con niveles de expresión, entonces genes con baja expresión tendrán una desviación estándar mayor que los genes de alta expresión debido al tipo de distribución de los datos de RNA-seq). El parámetro blind es TRUE por default porque este re-estima las dispersiones empleando solo un intercepto. Esto no es adecuado si se espera que la mayoría de los genes tengan grandes diferencias en sus conteos (lo que puede causar grandes estimados de dispersión por el diseño experimental y no por una diferencia biológica).\n\n## Variance stabilizing transformation\nvsd &lt;- vst(dds,blind = FALSE)\n\n## Plot\nvsn::meanSdPlot(assay(vsd))\n\n\n\n\n\n\n\n\n\n\n3.5.2 Extract the top DEG’s from top to bottom\nUna vez que ya se tiene la normalización con vsd, se puede proceder a extraer los DEG’s de interés para cada una de las comparaciones.\n\n## Extract the results for each condition\nres_LP_vs_Basal &lt;- results(dds, contrast = c(\"group\", \"LP\", \"Basal\"))\nres_ML_vs_Basal &lt;- results(dds, contrast = c(\"group\", \"ML\", \"Basal\"))\n\n## Add gene names\nres_LP_vs_Basal$SYMBOL &lt;- rowData(dds[rownames(res_LP_vs_Basal)])$SYMBOL\nres_ML_vs_Basal$SYMBOL &lt;- rowData(dds[rownames(res_ML_vs_Basal)])$SYMBOL\nres_LP_vs_Basal$ENTREZID &lt;- rowData(dds[rownames(res_LP_vs_Basal)])$ENTREZID\nres_ML_vs_Basal$ENTREZID &lt;- rowData(dds[rownames(res_ML_vs_Basal)])$ENTREZID\n\n## Filter the results\nres_LP_vs_Basal_sig &lt;- res_LP_vs_Basal[which(res_LP_vs_Basal$padj &lt; 0.05), ]\nres_LP_vs_Basal_sig &lt;- res_LP_vs_Basal_sig[order(res_LP_vs_Basal_sig$padj, decreasing = FALSE), ]\n\nres_ML_vs_Basal_sig &lt;- res_ML_vs_Basal[which(res_ML_vs_Basal$padj &lt; 0.05), ]\nres_ML_vs_Basal_sig &lt;- res_ML_vs_Basal_sig[order(res_ML_vs_Basal_sig$padj, decreasing = FALSE), ]\n\nVolcano plot\n\npar(mfrow=c(1,2))\n\nplotVolcano(df = res_LP_vs_Basal_sig,\n            pval_col = \"pvalue\",\n            lfc_col = \"log2FoldChange\",\n            adjpval_col = \"padj\",\n            plot_title = \"Basal vs. LP\")\n\n## [1] TRUE\n\nplotVolcano(df = res_ML_vs_Basal_sig,\n            pval_col = \"pvalue\",\n            lfc_col = \"log2FoldChange\",\n            adjpval_col = \"padj\",\n            plot_title = \"Basal vs. ML\")\n\n\n\n\n\n\n\n\n## [1] TRUE\n\n\nHeatmap\n\n## Basal vs. LP heatmap\nbasal.vs.lp.topgenes.deseq &lt;- res_LP_vs_Basal_sig$ENTREZID[1:100]\ni &lt;- which(rowData(dds)$ENTREZID %in% basal.vs.lp.topgenes.deseq)\n\nhmap.palette &lt;- colorRampPalette(c(\"red\", \"white\", \"blue\"))\npheatmap::pheatmap(assay(vsd)[i,],\n                   scale = \"row\",\n                   cluster_rows = TRUE,\n                   labels_row = rowData(dds[i])$SYMBOL,\n                   labels_col = group,\n                   color = hmap.palette(100),\n                   main = \"Basal vs. LP\")\n\n\n\n\n\n\n\n## Basal vs. ML heatmap\nbasal.vs.ml.topgenes.deseq &lt;- res_ML_vs_Basal_sig$ENTREZID[1:100]\ni &lt;- which(rowData(dds)$ENTREZID %in% basal.vs.ml.topgenes.deseq)\n\nhmap.palette &lt;- colorRampPalette(c(\"red\", \"white\", \"blue\"))\npheatmap::pheatmap(assay(vsd)[i,],\n                   scale = \"row\",\n                   cluster_rows = TRUE,\n                   labels_row = rowData(dds[i])$SYMBOL,\n                   labels_col = group,\n                   color = hmap.palette(100),\n                   main = \"Basal vs. ML\")",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Análisis de Expresión Diferencial</span>"
    ]
  },
  {
    "objectID": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#reproducibilidad",
    "href": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#reproducibilidad",
    "title": "Análisis de Expresión Diferencial I",
    "section": "Reproducibilidad",
    "text": "Reproducibilidad\n\nR\n\n\n## ─ Session info ───────────────────────────────────────────────────────────────\n##  setting  value\n##  version  R version 4.4.2 (2024-10-31 ucrt)\n##  os       Windows 11 x64 (build 26100)\n##  system   x86_64, mingw32\n##  ui       RTerm\n##  language (EN)\n##  collate  English_United States.utf8\n##  ctype    English_United States.utf8\n##  tz       America/Mexico_City\n##  date     2025-01-21\n##  pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n## \n## ─ Packages ───────────────────────────────────────────────────────────────────\n##  package                            * version    date (UTC) lib source\n##  abind                                1.4-8      2024-09-12 [1] CRAN (R 4.4.1)\n##  affy                                 1.84.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  affyio                               1.76.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  AnnotationDbi                      * 1.68.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  apeglm                               1.28.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  bbmle                                1.0.25.1   2023-12-09 [1] CRAN (R 4.4.2)\n##  bdsmatrix                            1.3-7      2024-03-02 [1] CRAN (R 4.4.0)\n##  Biobase                            * 2.66.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  BiocFileCache                        2.14.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  BiocGenerics                       * 0.52.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  BiocIO                               1.16.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  BiocManager                          1.30.25    2024-08-28 [1] CRAN (R 4.4.2)\n##  BiocParallel                         1.40.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  biomaRt                              2.62.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  Biostrings                           2.74.1     2024-12-16 [1] Bioconductor 3.20 (R 4.4.2)\n##  bit                                  4.5.0.1    2024-12-03 [1] CRAN (R 4.4.2)\n##  bit64                                4.5.2      2024-09-22 [1] CRAN (R 4.4.2)\n##  bitops                               1.0-9      2024-10-03 [1] CRAN (R 4.4.1)\n##  blob                                 1.2.4      2023-03-17 [1] CRAN (R 4.4.2)\n##  cachem                               1.1.0      2024-05-16 [1] CRAN (R 4.4.2)\n##  cli                                  3.6.3      2024-06-21 [1] CRAN (R 4.4.2)\n##  coda                                 0.19-4.1   2024-01-31 [1] CRAN (R 4.4.2)\n##  codetools                            0.2-20     2024-03-31 [2] CRAN (R 4.4.2)\n##  colorspace                           2.1-1      2024-07-26 [1] CRAN (R 4.4.2)\n##  crayon                               1.5.3      2024-06-20 [1] CRAN (R 4.4.2)\n##  curl                                 6.0.1      2024-11-14 [1] CRAN (R 4.4.2)\n##  DBI                                  1.2.3      2024-06-02 [1] CRAN (R 4.4.2)\n##  dbplyr                               2.5.0      2024-03-19 [1] CRAN (R 4.4.2)\n##  DelayedArray                         0.32.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  DESeq2                             * 1.46.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  digest                               0.6.37     2024-08-19 [1] CRAN (R 4.4.2)\n##  dplyr                                1.1.4      2023-11-17 [1] CRAN (R 4.4.2)\n##  edgeR                              * 4.4.1      2024-12-02 [1] Bioconductor 3.20 (R 4.4.2)\n##  emdbook                              1.3.13     2023-07-03 [1] CRAN (R 4.4.2)\n##  evaluate                             1.0.1      2024-10-10 [1] CRAN (R 4.4.2)\n##  farver                               2.1.2      2024-05-13 [1] CRAN (R 4.4.2)\n##  fastmap                              1.2.0      2024-05-15 [1] CRAN (R 4.4.2)\n##  filelock                             1.0.3      2023-12-11 [1] CRAN (R 4.4.2)\n##  generics                             0.1.3      2022-07-05 [1] CRAN (R 4.4.2)\n##  GenomeInfoDb                       * 1.42.1     2024-11-28 [1] Bioconductor 3.20 (R 4.4.2)\n##  GenomeInfoDbData                     1.2.13     2024-12-22 [1] Bioconductor\n##  GenomicAlignments                    1.42.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  GenomicFeatures                    * 1.58.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  GenomicRanges                      * 1.58.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  ggplot2                              3.5.1      2024-04-23 [1] CRAN (R 4.4.2)\n##  ggVennDiagram                      * 1.5.2      2024-02-20 [1] CRAN (R 4.4.2)\n##  Glimma                             * 2.16.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  glue                                 1.8.0      2024-09-30 [1] CRAN (R 4.4.2)\n##  GO.db                              * 3.20.0     2024-12-22 [1] Bioconductor\n##  graph                                1.84.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  gtable                               0.3.6      2024-10-25 [1] CRAN (R 4.4.2)\n##  hexbin                               1.28.5     2024-11-13 [1] CRAN (R 4.4.2)\n##  hms                                  1.1.3      2023-03-21 [1] CRAN (R 4.4.2)\n##  htmltools                            0.5.8.1    2024-04-04 [1] CRAN (R 4.4.2)\n##  htmlwidgets                          1.6.4      2023-12-06 [1] CRAN (R 4.4.2)\n##  httr                                 1.4.7      2023-08-15 [1] CRAN (R 4.4.2)\n##  httr2                                1.0.7      2024-11-26 [1] CRAN (R 4.4.2)\n##  IRanges                            * 2.40.1     2024-12-05 [1] Bioconductor 3.20 (R 4.4.2)\n##  jsonlite                             1.8.9      2024-09-20 [1] CRAN (R 4.4.2)\n##  KEGGREST                             1.46.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  KernSmooth                           2.23-24    2024-05-17 [2] CRAN (R 4.4.2)\n##  knitr                                1.49       2024-11-08 [1] CRAN (R 4.4.2)\n##  labeling                             0.4.3      2023-08-29 [1] CRAN (R 4.4.0)\n##  lattice                              0.22-6     2024-03-20 [2] CRAN (R 4.4.2)\n##  lifecycle                            1.0.4      2023-11-07 [1] CRAN (R 4.4.2)\n##  limma                              * 3.62.1     2024-11-03 [1] Bioconductor 3.20 (R 4.4.1)\n##  locfit                               1.5-9.10   2024-06-24 [1] CRAN (R 4.4.2)\n##  magrittr                             2.0.3      2022-03-30 [1] CRAN (R 4.4.2)\n##  MASS                                 7.3-61     2024-06-13 [2] CRAN (R 4.4.2)\n##  Matrix                               1.7-1      2024-10-18 [2] CRAN (R 4.4.2)\n##  MatrixGenerics                     * 1.18.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  matrixStats                        * 1.4.1      2024-09-08 [1] CRAN (R 4.4.2)\n##  memoise                              2.0.1      2021-11-26 [1] CRAN (R 4.4.2)\n##  munsell                              0.5.1      2024-04-01 [1] CRAN (R 4.4.2)\n##  Mus.musculus                       * 1.3.1      2024-12-27 [1] Bioconductor\n##  mvtnorm                              1.3-2      2024-11-04 [1] CRAN (R 4.4.2)\n##  numDeriv                             2016.8-1.1 2019-06-06 [1] CRAN (R 4.4.0)\n##  org.Mm.eg.db                       * 3.20.0     2024-12-22 [1] Bioconductor\n##  OrganismDbi                        * 1.48.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  pheatmap                             1.0.12     2019-01-04 [1] CRAN (R 4.4.2)\n##  pillar                               1.10.0     2024-12-17 [1] CRAN (R 4.4.2)\n##  pkgconfig                            2.0.3      2019-09-22 [1] CRAN (R 4.4.2)\n##  plyr                                 1.8.9      2023-10-02 [1] CRAN (R 4.4.2)\n##  png                                  0.1-8      2022-11-29 [1] CRAN (R 4.4.0)\n##  preprocessCore                       1.68.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  prettyunits                          1.2.0      2023-09-24 [1] CRAN (R 4.4.2)\n##  progress                             1.2.3      2023-12-06 [1] CRAN (R 4.4.2)\n##  R.methodsS3                          1.8.2      2022-06-13 [1] CRAN (R 4.4.0)\n##  R.oo                                 1.27.0     2024-11-01 [1] CRAN (R 4.4.1)\n##  R.utils                              2.12.3     2023-11-18 [1] CRAN (R 4.4.2)\n##  R6                                   2.5.1      2021-08-19 [1] CRAN (R 4.4.2)\n##  rappdirs                             0.3.3      2021-01-31 [1] CRAN (R 4.4.2)\n##  RBGL                                 1.82.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  RColorBrewer                         1.1-3      2022-04-03 [1] CRAN (R 4.4.0)\n##  Rcpp                                 1.0.13-1   2024-11-02 [1] CRAN (R 4.4.2)\n##  RCurl                                1.98-1.16  2024-07-11 [1] CRAN (R 4.4.1)\n##  restfulr                             0.0.15     2022-06-16 [1] CRAN (R 4.4.2)\n##  reticulate                         * 1.40.0     2024-11-15 [1] CRAN (R 4.4.2)\n##  rjson                                0.2.23     2024-09-16 [1] CRAN (R 4.4.1)\n##  rlang                                1.1.4      2024-06-04 [1] CRAN (R 4.4.2)\n##  rmarkdown                            2.29       2024-11-04 [1] CRAN (R 4.4.2)\n##  Rsamtools                            2.22.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  RSQLite                              2.3.9      2024-12-03 [1] CRAN (R 4.4.2)\n##  rstudioapi                           0.17.1     2024-10-22 [1] CRAN (R 4.4.2)\n##  rtracklayer                          1.66.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  S4Arrays                             1.6.0      2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  S4Vectors                          * 0.44.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  scales                               1.3.0      2023-11-28 [1] CRAN (R 4.4.2)\n##  sessioninfo                          1.2.2      2021-12-06 [1] CRAN (R 4.4.2)\n##  SparseArray                          1.6.0      2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  statmod                              1.5.0      2023-01-06 [1] CRAN (R 4.4.2)\n##  stringi                              1.8.4      2024-05-06 [1] CRAN (R 4.4.0)\n##  stringr                              1.5.1      2023-11-14 [1] CRAN (R 4.4.2)\n##  SummarizedExperiment               * 1.36.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  tibble                               3.2.1      2023-03-20 [1] CRAN (R 4.4.2)\n##  tidyselect                           1.2.1      2024-03-11 [1] CRAN (R 4.4.2)\n##  TxDb.Mmusculus.UCSC.mm10.knownGene * 3.10.0     2024-12-22 [1] Bioconductor\n##  txdbmaker                            1.2.1      2024-11-25 [1] Bioconductor 3.20 (R 4.4.2)\n##  UCSC.utils                           1.2.0      2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  vctrs                                0.6.5      2023-12-01 [1] CRAN (R 4.4.2)\n##  vsn                                  3.74.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  withr                                3.0.2      2024-10-28 [1] CRAN (R 4.4.2)\n##  xfun                                 0.49       2024-10-31 [1] CRAN (R 4.4.2)\n##  XML                                  3.99-0.17  2024-06-25 [1] CRAN (R 4.4.1)\n##  xml2                                 1.3.6      2023-12-04 [1] CRAN (R 4.4.2)\n##  XVector                              0.46.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  yaml                                 2.3.10     2024-07-26 [1] CRAN (R 4.4.1)\n##  zlibbioc                             1.52.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n## \n##  [1] C:/Users/chomb/AppData/Local/R/win-library/4.4\n##  [2] C:/Program Files/R/R-4.4.2/library\n## \n## ─ Python configuration ───────────────────────────────────────────────────────\n##  python:         C:/Users/chomb/AppData/Local/Programs/Python/Python312/python.exe\n##  libpython:      C:/Users/chomb/AppData/Local/Programs/Python/Python312/python312.dll\n##  pythonhome:     C:/Users/chomb/AppData/Local/Programs/Python/Python312\n##  version:        3.12.4 (tags/v3.12.4:8e8a4ba, Jun  6 2024, 19:30:16) [MSC v.1940 64 bit (AMD64)]\n##  Architecture:   64bit\n##  numpy:          C:/Users/chomb/AppData/Local/Programs/Python/Python312/Lib/site-packages/numpy\n##  numpy_version:  2.0.2\n##  \n##  NOTE: Python version was forced by use_python() function\n## \n## ──────────────────────────────────────────────────────────────────────────────\n\n\n\n\nPython\n\n\n## -----\n## anndata             0.11.1\n## matplotlib          3.10.0\n## numpy               2.0.2\n## pandas              2.2.3\n## pydeseq2            0.4.12\n## sanbomics           NA\n## scanpy              1.10.4\n## seaborn             0.13.2\n## session_info        1.0.0\n## -----\n## Python 3.12.4 (tags/v3.12.4:8e8a4ba, Jun  6 2024, 19:30:16) [MSC v.1940 64 bit (AMD64)]\n## Windows-11-10.0.26100-SP0\n## -----\n## Session information updated at 2025-01-21 14:50",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Análisis de Expresión Diferencial</span>"
    ]
  },
  {
    "objectID": "chapters/Clase12_SingleCellRNAseq.html",
    "href": "chapters/Clase12_SingleCellRNAseq.html",
    "title": "Single-cell RNA-seq",
    "section": "",
    "text": "1. Motivación",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell RNA-seq</span>"
    ]
  },
  {
    "objectID": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#edger-limma",
    "href": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#edger-limma",
    "title": "Análisis de Expresión Diferencial I",
    "section": "2. EdgeR / Limma",
    "text": "2. EdgeR / Limma\nEdgeR es una librería de R que se usa para realizar análisis de expresión diferencial de genes provenientes de datos de RNA-seq. Esta librería emplea métodos estadísticos para experimentos multigrupo basados en modelos lineares generalizados (generalized linear models: glms) los cuales son eficientes para experimentos multifactoriales independientemente de su complejidad. También implementa métodos Bayesianos que permiten la estimación de la variación biológica genética-específica, incluso para experimentos con los mínimos niveles de replicación biológica.\n\nDocumentación (EdgeR)\nDOI: https://doi.org/10.1093/bioinformatics/btp616\n\n\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\", quiet = TRUE)\n\nif (!require(edgeR, quietly = TRUE))\n    BiocManager::install(\"edgeR\",quiet = TRUE)\n\nLimma es una librería de R que fue creada para el ánalisis de expresión diferencial para datos provenientes de microarreglos. Usa principalmente modelos lineales para experimentos multigrupos.\n\nDocumentación (limma)\nDOI: https://doi.org/10.1093/nar/gkv007\n\n\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\", quiet = TRUE)\n\nif (!require(limma, quietly = TRUE))\n    BiocManager::install(\"limma\",quiet = TRUE)\n\n\n2.1 Load libraries\n\nsuppressPackageStartupMessages(library(limma))\nsuppressPackageStartupMessages(library(Glimma))\nsuppressPackageStartupMessages(library(edgeR))\nsuppressPackageStartupMessages(library(Mus.musculus))\n\n\n\n2.2 Read files\n\nx &lt;- readDGE(file.path(tempdir(),\"GSE63310/\",files),\n             columns = c(1,3))\nclass(x)\n\n## [1] \"DGEList\"\n## attr(,\"package\")\n## [1] \"edgeR\"\n\ndim(x)\n\n## [1] 27179     9\n\n\n\n2.2.1 Reorganize information\n\n## Assign sample type and sample names\nsamplenames &lt;- substring(colnames(x),67)\nsamplenames\n\n## [1] \"10_6_5_11\" \"9_6_5_11\"  \"purep53\"   \"JMS8-2\"    \"JMS8-3\"    \"JMS8-4\"   \n## [7] \"JMS8-5\"    \"JMS9-P7c\"  \"JMS9-P8c\"\n\ncolnames(x) &lt;- samplenames\ngroup &lt;- as.factor(c(\"LP\", \"ML\", \"Basal\", \"Basal\", \"ML\", \"LP\",\n                     \"Basal\", \"ML\", \"LP\"))\nx$samples$group &lt;- group\nlane &lt;- as.factor(rep(c(\"L004\",\"L006\",\"L008\"), c(3,4,2)))\nx$samples$lane &lt;- lane\nx$samples\n\n\n  \n\n\n\n\n\n2.2.2 Add gene names\n\ngenes &lt;- AnnotationDbi::select(Mus.musculus,\n                        keys = rownames(x),\n                        columns = c(\"SYMBOL\",\"TXCHROM\"),\n                        keytype = \"ENTREZID\")\n\n## Remove duplicates\ngenes &lt;- genes[!duplicated(genes$ENTREZID),]\nhead(genes)\n\n\n  \n\n\n## Add genes\nx$genes &lt;- genes\nx\n\n## An object of class \"DGEList\"\n## $samples\n##                                                                                           files\n## 10_6_5_11 C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545535_10_6_5_11.txt\n## 9_6_5_11   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545536_9_6_5_11.txt\n## purep53     C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545538_purep53.txt\n## JMS8-2       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545539_JMS8-2.txt\n## JMS8-3       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545540_JMS8-3.txt\n## JMS8-4       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545541_JMS8-4.txt\n## JMS8-5       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545542_JMS8-5.txt\n## JMS9-P7c   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545544_JMS9-P7c.txt\n## JMS9-P8c   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545545_JMS9-P8c.txt\n##           group lib.size norm.factors lane\n## 10_6_5_11    LP 32863052            1 L004\n## 9_6_5_11     ML 35335491            1 L004\n## purep53   Basal 57160817            1 L004\n## JMS8-2    Basal 51368625            1 L006\n## JMS8-3       ML 75795034            1 L006\n## JMS8-4       LP 60517657            1 L006\n## JMS8-5    Basal 55086324            1 L006\n## JMS9-P7c     ML 21311068            1 L008\n## JMS9-P8c     LP 19958838            1 L008\n## \n## $counts\n##            Samples\n## Tags        10_6_5_11 9_6_5_11 purep53 JMS8-2 JMS8-3 JMS8-4 JMS8-5 JMS9-P7c\n##   497097            1        2     342    526      3      3    535        2\n##   100503874         0        0       5      6      0      0      5        0\n##   100038431         0        0       0      0      0      0      1        0\n##   19888             0        1       0      0     17      2      0        1\n##   20671             1        1      76     40     33     14     98       18\n##            Samples\n## Tags        JMS9-P8c\n##   497097           0\n##   100503874        0\n##   100038431        0\n##   19888            0\n##   20671            8\n## 27174 more rows ...\n## \n## $genes\n##    ENTREZID  SYMBOL TXCHROM\n## 1    497097    Xkr4    chr1\n## 2 100503874 Gm19938    &lt;NA&gt;\n## 3 100038431 Gm10568    &lt;NA&gt;\n## 4     19888     Rp1    chr1\n## 5     20671   Sox17    chr1\n## 27174 more rows ...\n\n\n\n\n\n2.3 Data preprocessing\n\n## counts per million\ncpm.obj &lt;- cpm(x)\n\n## log counts per million transformation\nlcpm.obj &lt;- cpm(x, log = TRUE)\n\n## Mean and median\nL &lt;- mean(x$samples$lib.size) * 1e-6\nM &lt;- median(x$samples$lib.size) * 1e-6\nc(L, M)\n\n## [1] 45.48855 51.36862\n\n## The average library size is about 45.5 million and the minimum\n## log-CPM should be log2(2/45.5) = -4.51 which means that\n## a count of 0 maps to a log-CPM value of -4.51\nsummary(lcpm.obj)\n\n##    10_6_5_11          9_6_5_11          purep53             JMS8-2       \n##  Min.   :-4.5074   Min.   :-4.5074   Min.   :-4.50743   Min.   :-4.5074  \n##  1st Qu.:-4.5074   1st Qu.:-4.5074   1st Qu.:-4.50743   1st Qu.:-4.5074  \n##  Median :-0.6847   Median :-0.3589   Median :-0.09513   Median :-0.0901  \n##  Mean   : 0.1714   Mean   : 0.3312   Mean   : 0.43559   Mean   : 0.4089  \n##  3rd Qu.: 4.2913   3rd Qu.: 4.5601   3rd Qu.: 4.60081   3rd Qu.: 4.5475  \n##  Max.   :14.7632   Max.   :13.4952   Max.   :12.95700   Max.   :12.8513  \n##      JMS8-3            JMS8-4            JMS8-5            JMS9-P7c      \n##  Min.   :-4.5074   Min.   :-4.5074   Min.   :-4.50743   Min.   :-4.5074  \n##  1st Qu.:-4.5074   1st Qu.:-4.5074   1st Qu.:-4.50743   1st Qu.:-4.5074  \n##  Median :-0.4281   Median :-0.4064   Median :-0.07152   Median :-0.1704  \n##  Mean   : 0.3225   Mean   : 0.2529   Mean   : 0.40428   Mean   : 0.3708  \n##  3rd Qu.: 4.5772   3rd Qu.: 4.3199   3rd Qu.: 4.42513   3rd Qu.: 4.6031  \n##  Max.   :12.9578   Max.   :14.8520   Max.   :13.19491   Max.   :12.9413  \n##     JMS9-P8c      \n##  Min.   :-4.5074  \n##  1st Qu.:-4.5074  \n##  Median :-0.3300  \n##  Mean   : 0.2749  \n##  3rd Qu.: 4.4355  \n##  Max.   :14.0102\n\n\n\n\n2.4 Remove genes that are lowly expressed\n\n## Remove all the genes that have 0 counts across the nine samples\ntable(rowSums(x$counts==0)==9)\n\n## \n## FALSE  TRUE \n## 22026  5153\n\n## Filter by expression\nkeep.exprs &lt;- filterByExpr(x,group = group)\nx &lt;- x[keep.exprs,,keep.lib.sizes=FALSE]\ndim(x)\n\n## [1] 16624     9\n\n\n\n\n2.5 Normalize gene expression\nSe necesita normalizar debido a que los datos de RNA-Seq contienen sesgos técnicos y biológicos que pueden distorsionar los resultados si no se corrigen. Las razones principales para normalizar son: diferencias de profundidad de secuenciación, diferencias en la composición génica, comparabilidad entre muestras, impacto de la longitud de los genes, preparación para métodos estadísticos.\nMétodos comunes de normalización:\n\nTMM (Trimmed Mean of M-values): Corrige la profundidad de secuenciación y la composición génica.\nRPKM/FPKM (Reads/Fragments Per Kilobase Million): Normaliza por la longitud del gen y el tamaño total de las muestras.\nTPM (Transcripts Per Million): Similar a RPKM, pero mejora la comparabilidad entre muestras.\nDESeq2/EdgeR Scaling Factors: Ajustan los conteos para análisis estadísticos robustos.\n\n\n## Normalize\nx &lt;- calcNormFactors(x,method = \"TMM\") # Trimmed mean of M-values\nx$samples$norm.factors\n\n## [1] 0.8943956 1.0250186 1.0459005 1.0458455 1.0162707 0.9217132 0.9961959\n## [8] 1.0861026 0.9839203\n\n\nComparación entre normalizar o no\n\nx2 &lt;- x\nx2$samples$norm.factors &lt;- 1\nx2$counts[,1] &lt;- ceiling(x2$counts[,1]*0.05)\nx2$counts[,2] &lt;- x2$counts[,2]*5\n\nVisualización:\n\ncol &lt;- c(\"#A6CEE3\",\"#1F78B4\",\"#B2DF8A\",\"#33A02C\",\"#FB9A99\",\"#E31A1C\",\"#FDBF6F\",\"#FF7F00\",\"#CAB2D6\")\npar(mfrow=c(1,2))\nlcpm &lt;- cpm(x2, log=TRUE)\nboxplot(lcpm, las=2, col=col, main=\"\")\ntitle(main=\"A. Example: Unnormalised data\",ylab=\"Log-cpm\")\nx2 &lt;- calcNormFactors(x2)  \nx2$samples$norm.factors\n\n## [1] 0.05770899 6.08287835 1.22023972 1.16478991 1.19661094 1.04659233 1.15048074\n## [8] 1.25431164 1.10901983\n\nlcpm &lt;- cpm(x2, log=TRUE)\nboxplot(lcpm, las=2, col=col, main=\"\")\ntitle(main=\"B. Example: Normalised data\",ylab=\"Log-cpm\")\n\n\n\n\n\n\n\n\n\n\n2.6 Unsupervised clustering of samples\n\nUsar una MultiDimensional Scaling plot (MDS): esta muestra la similitudes y disimilitudes entre las muestras con algoritmo no supervisado. La primera dimensión representa el fold-change que mejor separa a las muestras y que explica la mayor proporción de la variancia de los datos. Aquí nos podemos dar cuenta si se deben de hacer algunas correcciones del batch.\n\n\nlcpm &lt;- cpm(x, log=TRUE)\n\n## Define colors\npar(mfrow=c(1,2))\ncol.group &lt;- group\nlevels(col.group) &lt;-  RColorBrewer::brewer.pal(nlevels(col.group), \"Set1\")\ncol.group &lt;- as.character(col.group)\n\n## Define colors\ncol.lane &lt;- lane\nlevels(col.lane) &lt;-  RColorBrewer::brewer.pal(nlevels(col.lane), \"Set2\")\ncol.lane &lt;- as.character(col.lane)\n\n## Plot MDS\nplotMDS(lcpm, labels=group, col=col.group)\ntitle(main=\"A. Sample groups\")\nplotMDS(lcpm, labels=lane, col=col.lane, dim=c(3,4))\ntitle(main=\"B. Sequencing lanes\")\n\n\n\n\n\n\n\n\n\n\n2.7 Differential expression analysis\n\n2.7.1 Create a matrix\nGenes que están expresados en diferentes niveles. Los modelos lineales se ajustan a los datos bajo la asunción de que los datos siguen una distribución normal (lo cual no es cierto porque siguen una distribución binomial negativa o una de poisson).\nEste diseño experimental quita el intercepto del primer factor group pero un intercepto permanece con el segundo factor lane. Es esencial entender cómo interpretar los coeficientes en el modelo.\n\ndesign &lt;- model.matrix(~0 + group + lane)\ncolnames(design) &lt;- gsub(\"group\",\"\",colnames(design))\ndesign\n\n##   Basal LP ML laneL006 laneL008\n## 1     0  1  0        0        0\n## 2     0  0  1        0        0\n## 3     1  0  0        0        0\n## 4     1  0  0        1        0\n## 5     0  0  1        1        0\n## 6     0  1  0        1        0\n## 7     1  0  0        1        0\n## 8     0  0  1        0        1\n## 9     0  1  0        0        1\n## attr(,\"assign\")\n## [1] 1 1 1 2 2\n## attr(,\"contrasts\")\n## attr(,\"contrasts\")$group\n## [1] \"contr.treatment\"\n## \n## attr(,\"contrasts\")$lane\n## [1] \"contr.treatment\"\n\ncontr.matrix &lt;- makeContrasts(\n   BasalvsLP = Basal-LP, \n   BasalvsML = Basal - ML, \n   LPvsML = LP - ML, \n   levels = colnames(design))\ncontr.matrix\n\n##           Contrasts\n## Levels     BasalvsLP BasalvsML LPvsML\n##   Basal            1         1      0\n##   LP              -1         0      1\n##   ML               0        -1     -1\n##   laneL006         0         0      0\n##   laneL008         0         0      0\n\n\n\n\n2.7.2 Removing heteroscedascity from count data\nPara los datos de RNA-seq la varianza no es independiente de la media sin importar si los datos sufren una transformación logarítmica o no. Los modelos que asumen una distribución binomial negativa asumen una relación cuadrática media-varianza.\nEl plot de voom ilustra la relación media-varianza. Este plot muestra una trend que decrece entre la media y la varianza como resultado de la combinación de la varianza técnica en los experimentos de secuenciación y de la varianza biológica entre las réplicas de las muestras de las diferentes poblaciones celulares.\nExperimentos con una variación biológica alta resultan en tendencias más planas.\nExperimentos con una variación biológica baja reusltan en tendencias decrecientes pronunciadas.\nSi no se tienen más de 3 réplicas se opta por usar un GLM o si se desea usar un modelo específico para RNA-seq.\n\npar(mfrow=c(1,2))\nv &lt;- voom(x, design, plot=TRUE)\nv\n\n## An object of class \"EList\"\n## $genes\n##   ENTREZID SYMBOL TXCHROM\n## 1   497097   Xkr4    chr1\n## 5    20671  Sox17    chr1\n## 6    27395 Mrpl15    chr1\n## 7    18777 Lypla1    chr1\n## 9    21399  Tcea1    chr1\n## 16619 more rows ...\n## \n## $targets\n##                                                                                           files\n## 10_6_5_11 C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545535_10_6_5_11.txt\n## 9_6_5_11   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545536_9_6_5_11.txt\n## purep53     C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545538_purep53.txt\n## JMS8-2       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545539_JMS8-2.txt\n## JMS8-3       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545540_JMS8-3.txt\n## JMS8-4       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545541_JMS8-4.txt\n## JMS8-5       C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545542_JMS8-5.txt\n## JMS9-P7c   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545544_JMS9-P7c.txt\n## JMS9-P8c   C:\\\\Users\\\\chomb\\\\AppData\\\\Local\\\\Temp\\\\RtmpwZFj5a/GSE63310//GSM1545545_JMS9-P8c.txt\n##           group lib.size norm.factors lane\n## 10_6_5_11    LP 29387429    0.8943956 L004\n## 9_6_5_11     ML 36212498    1.0250186 L004\n## purep53   Basal 59771061    1.0459005 L004\n## JMS8-2    Basal 53711278    1.0458455 L006\n## JMS8-3       ML 77015912    1.0162707 L006\n## JMS8-4       LP 55769890    0.9217132 L006\n## JMS8-5    Basal 54863512    0.9961959 L006\n## JMS9-P7c     ML 23139691    1.0861026 L008\n## JMS9-P8c     LP 19634459    0.9839203 L008\n## \n## $E\n##         Samples\n## Tags     10_6_5_11  9_6_5_11   purep53     JMS8-2    JMS8-3    JMS8-4    JMS8-5\n##   497097 -4.292165 -3.856488 2.5185849  3.2931366 -4.459730 -3.994060 3.2869677\n##   20671  -4.292165 -4.593453 0.3560126 -0.4073032 -1.200995 -1.943434 0.8442767\n##   27395   3.876089  4.413107 4.5170045  4.5617546  4.344401  3.786363 3.8990635\n##   18777   4.708774  5.571872 5.3964008  5.1623650  5.649355  5.081611 5.0602470\n##   21399   4.785541  4.754537 5.3703795  5.1220551  4.869586  4.943840 5.1384776\n##         Samples\n## Tags       JMS9-P7c  JMS9-P8c\n##   497097 -3.2103696 -5.295316\n##   20671  -0.3228444 -1.207853\n##   27395   4.3396075  4.124644\n##   18777   5.7513694  5.142436\n##   21399   5.0308985  4.979644\n## 16619 more rows ...\n## \n## $weights\n##           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]\n## [1,]  1.079413  1.332986 19.826915 20.273253  1.993686  1.395853 20.494977\n## [2,]  1.170357  1.456380  4.804866  8.660025  3.612508  2.626870  8.760149\n## [3,] 20.219073 25.573792 30.434759 28.528310 31.352260 25.743247 28.722497\n## [4,] 26.947557 32.505933 33.583128 33.232125 34.231754 32.354158 33.334340\n## [5,] 26.610864 28.501638 33.645479 33.206374 33.573492 31.996623 33.308490\n##           [,8]      [,9]\n## [1,]  1.107780  1.079413\n## [2,]  3.211473  2.541942\n## [3,] 21.200072 16.657930\n## [4,] 30.348630 24.259801\n## [5,] 25.171513 23.573305\n## 16619 more rows ...\n## \n## $design\n##   Basal LP ML laneL006 laneL008\n## 1     0  1  0        0        0\n## 2     0  0  1        0        0\n## 3     1  0  0        0        0\n## 4     1  0  0        1        0\n## 5     0  0  1        1        0\n## 6     0  1  0        1        0\n## 7     1  0  0        1        0\n## 8     0  0  1        0        1\n## 9     0  1  0        0        1\n## attr(,\"assign\")\n## [1] 1 1 1 2 2\n## attr(,\"contrasts\")\n## attr(,\"contrasts\")$group\n## [1] \"contr.treatment\"\n## \n## attr(,\"contrasts\")$lane\n## [1] \"contr.treatment\"\n\nvfit &lt;- lmFit(v, design)\nvfit &lt;- contrasts.fit(vfit, contrasts=contr.matrix)\nefit &lt;- eBayes(vfit)\nplotSA(efit, main=\"Final model: Mean-variance trend\")\n\n\n\n\n\n\n\n\nSi no se tienen más de 3 réplicas se opta por usar un GLM o si se desea usar un modelo específico para RNA-seq.\n\n## Adjust GLM\nx &lt;- estimateDisp(x, design)\nfit &lt;- glmQLFit(x, design)\n\n## Make contrast matrices\ncontr.matrix &lt;- makeContrasts(\n   BasalvsLP = Basal-LP, \n   BasalvsML = Basal - ML, \n   LPvsML = LP - ML, \n   levels = colnames(design))\ncontr.matrix\n\n##           Contrasts\n## Levels     BasalvsLP BasalvsML LPvsML\n##   Basal            1         1      0\n##   LP              -1         0      1\n##   ML               0        -1     -1\n##   laneL006         0         0      0\n##   laneL008         0         0      0\n\n## Fit the model\nqlf_basal_vs_lp &lt;- glmQLFTest(fit, contrast=contr.matrix[,\"BasalvsLP\"])\nqlf_basal_vs_ml &lt;- glmQLFTest(fit, contrast=contr.matrix[,\"BasalvsML\"])\n\n## Results\ntop_basal_vs_lp &lt;- topTags(qlf_basal_vs_lp, n=Inf)\nhead(top_basal_vs_lp$table)\n\n\n  \n\n\ntop_basal_vs_ml &lt;- topTags(qlf_basal_vs_ml, n=Inf)\nhead(top_basal_vs_ml$table)\n\n\n  \n\n\n## Visualización del ajuste de dispersión\nplotQLDisp(fit, main=\"Dispersion trend under GLM-QL\")\n\n\n\n\n\n\n\n## Summary of the results\nsummary(decideTests(qlf_basal_vs_lp))\n\n##        1*Basal -1*LP\n## Down            4613\n## NotSig          7032\n## Up              4979\n\nsummary(decideTests(qlf_basal_vs_ml))\n\n##        1*Basal -1*ML\n## Down            4889\n## NotSig          6852\n## Up              4883\n\n\n\n\n2.7.1 Examining the number of DE genes\nLa significancia está dada por el threshold al p-value ajustado (5%). Aunque a veces se emplea el valor del log-foldchange como threshold.\n\n## Using adjusted p-value\nsummary(decideTests(efit))\n\n##        BasalvsLP BasalvsML LPvsML\n## Down        4648      4927   3135\n## NotSig      7113      7026  10972\n## Up          4863      4671   2517\n\n## Using log-foldchange\ntfit &lt;- treat(vfit, lfc=1)\ndt &lt;- decideTests(tfit)\nsummary(dt)\n\n##        BasalvsLP BasalvsML LPvsML\n## Down        1632      1777    224\n## NotSig     12976     12790  16210\n## Up          2016      2057    190\n\n## Extract the DEG's shared between both conditions\nde.common &lt;- which(dt[,1]!=0 & dt[,2]!=0)\nlength(de.common)\n\n## [1] 2784\n\nvennDiagram(dt[,1:2], circle.col=c(\"turquoise\", \"salmon\"))\n\n\n\n\n\n\n\n\n\n\n2.7.1 Examining individual DE genes from top to bottom\nExtraer los resultados más significativos.\n\n## CHeck ?topTreat for more details\nbasal.vs.lp &lt;- topTreat(tfit, coef=1, n=Inf)\n\nbasal.vs.ml &lt;- topTreat(tfit, coef=2, n=Inf)\nhead(basal.vs.lp)\n\n\n  \n\n\nhead(basal.vs.ml)\n\n\n  \n\n\n\n\n\n2.7.1 Useful graphical representations of differential expression results\nMD plot\n\nplotMD(tfit, column=1, status=dt[,1], main=colnames(tfit)[1], \n       xlim=c(-8,13))\n\n\n\n\n\n\n\n\nVolcano plot\n\npar(mfrow=c(1,2))\n\nplotVolcano(df = basal.vs.lp,\n            pval_col = \"P.Value\",\n            lfc_col = \"logFC\",\n            adjpval_col = \"adj.P.Val\",\n            plot_title = \"Basal vs. LP\")\n\n## [1] TRUE\n\nplotVolcano(df = basal.vs.ml,\n            pval_col = \"P.Value\",\n            lfc_col = \"logFC\",\n            adjpval_col = \"adj.P.Val\",\n            plot_title = \"Basal vs. LP\")\n\n\n\n\n\n\n\n\n## [1] TRUE\n\n\nHeatmap\n\n## Basal vs. LP heatmap\nbasal.vs.lp.topgenes &lt;- basal.vs.lp$ENTREZID[1:100]\ni &lt;- which(v$genes$ENTREZID %in% basal.vs.lp.topgenes)\n\nhmap.palette &lt;- colorRampPalette(c(\"red\", \"white\", \"blue\"))\npheatmap::pheatmap(lcpm[i,],\n                   scale = \"row\",\n                   cluster_rows = TRUE,\n                   labels_row = v$genes$SYMBOL[i],\n                   labels_col = group,\n                   color = hmap.palette(100),\n                   main = \"Basal vs. LP\")\n\n\n\n\n\n\n\n## Basal vs. ML heatmap\nbasal.vs.ml.topgenes &lt;- basal.vs.ml$ENTREZID[1:100]\ni &lt;- which(v$genes$ENTREZID %in% basal.vs.ml.topgenes)\n\nhmap.palette &lt;- colorRampPalette(c(\"red\", \"white\", \"blue\"))\npheatmap::pheatmap(lcpm[i,],\n                   scale = \"row\",\n                   cluster_rows = TRUE,\n                   labels_row = v$genes$SYMBOL[i],\n                   labels_col = group,\n                   color = hmap.palette(100),\n                   main = \"Basal vs. ML\")",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Análisis de Expresión Diferencial</span>"
    ]
  },
  {
    "objectID": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#pydeseq2",
    "href": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#pydeseq2",
    "title": "Análisis de Expresión Diferencial I",
    "section": "4. pyDESeq2",
    "text": "4. pyDESeq2\nEste es una librería de Pyhton la cual pretende implementar la librería original de R DESeq2 para el análisis de expresión diferencial con datos de bulk RNA-seq. Como es una implementación desde 0, hay algunos cambios importantes en términos de las funciones y de los valores que estas regresan.\n\nDocumentación (pyDESeq2)\nDOI: https://doi.org/10.1093/bioinformatics/btad547\n\n\npip install pydeseq2\n\n## Using conda\nconda env create -n pydeseq2\nconda activate pydeseq2\npip install pydeseq2\n\n\n4.1 Load libraries\n\nimport re\nimport numpy as np\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# %pip install sanbomics\nfrom sanbomics.plots import volcano\nfrom sanbomics.tools import id_map\n\n# %pip install pydeseq2\nfrom pydeseq2.dds import DeseqDataSet\nfrom pydeseq2.default_inference import DefaultInference\nfrom pydeseq2.ds import DeseqStats\n\n# %pip install scanpy\nimport scanpy as sc\n\n\n\n4.2 Read files\n\n## Import R files variable to python\nfiles = r.files\n\n## Empty df\ndfs = []\n\n## Read files\nfor file in files:\n    df = pd.read_csv(file, sep=\"\\t\",usecols = [\"EntrezID\",\"Count\"])\n    column_name = file.split(\"/\")[-1].replace(\".txt\",\"\")\n    column_name = re.sub(r\"^GSM15455\\d{2}_\", \"\", column_name)\n    df.rename(columns={\"Count\": column_name}, inplace=True)\n    \n    dfs.append(df)\n\n## Create the matrix\nmerged_matrix = pd.concat(\n    [df.set_index(\"EntrezID\") for df in dfs], axis=1\n).fillna(0)\n\n\n4.2.1 Create metadata\n\nmetadata = r.dds_metadata\n\n\n\n4.2.2 Add genes\n\ngenes = r.genes\n\n\n\n4.2.3 Pre-filter counts\n\n## We have 9 samples\nsmallest_group_size = 9\nkeep = np.sum(merged_matrix &gt;= 10, axis=1) &gt;= smallest_group_size\nmerged_matrix = merged_matrix[keep].copy()\n\n\n\n\n4.3 Create pyDESeq2 object\n\n## Create DESeq2 object\ninference = DefaultInference(n_cpus = 8)\ndds = DeseqDataSet(\n    counts = merged_matrix.T,\n    metadata = metadata,\n    design_factors = ['group', 'lane'],\n    inference = inference\n)\ndds.var = genes\n\n\n\n4.4 Differential Expression Analysis\n\n## Run DESeq2\ndds.deseq2()\n\n## Fitting size factors...\n## ... done in 0.00 seconds.\n## \n## Fitting dispersions...\n## ... done in 1.28 seconds.\n## \n## Fitting dispersion trend curve...\n## ... done in 0.15 seconds.\n## \n## Fitting MAP dispersions...\n## ... done in 1.35 seconds.\n## \n## Fitting LFCs...\n## ... done in 0.69 seconds.\n## \n## Calculating cook's distance...\n## ... done in 0.00 seconds.\n## \n## Replacing 0 outlier genes.\n\n## Retrieve stats\nresult = DeseqStats(dds,inference = inference)\nbasal_vs_lp = DeseqStats(dds, contrast=[\"group\", \"Basal\", \"LP\"], inference=inference)\nbasal_vs_ml = DeseqStats(dds, contrast=[\"group\", \"Basal\", \"ML\"], inference=inference)\n\n## Extract the results\nresult.summary()\n\n## Running Wald tests...\n## ... done in 0.38 seconds.\n## \n## Log2 fold change & Wald test p-value: lane L006 vs L004\n##               baseMean  log2FoldChange     lfcSE      stat    pvalue      padj\n## 11302       782.020723       -0.123189  0.202669 -0.607834  0.543297  0.875635\n## 11303      1651.935164        0.039150  0.159773  0.245032  0.806431  0.959511\n## 11304      1344.515458        0.006769  0.135751  0.049865  0.960230  0.992764\n## 11305       295.742823       -0.399928  0.211048 -1.894967  0.058097  0.416339\n## 11306      2356.502410        0.055302  0.137805  0.401304  0.688196  0.926800\n## ...                ...             ...       ...       ...       ...       ...\n## 100862251   838.908288        0.297839  0.232688  1.279994  0.200547  0.660890\n## 100862257  1041.025804       -0.139267  0.196478 -0.708816  0.478438  0.843321\n## 100862258  1534.037447       -0.227660  0.191033 -1.191730  0.233367  0.692072\n## 100862307   369.536157       -0.355791  0.216680 -1.642006  0.100589  0.523408\n## 100862400   855.267041       -0.344427  0.208666 -1.650609  0.098818  0.520729\n## \n## [13274 rows x 6 columns]\n\nres = result.results_df\nbasal_vs_lp.summary()\n\n## Running Wald tests...\n## ... done in 0.34 seconds.\n## \n## Log2 fold change & Wald test p-value: group Basal vs LP\n##               baseMean  log2FoldChange  ...        pvalue          padj\n## 11302       782.020723        0.523221  ...  2.276141e-02  4.015082e-02\n## 11303      1651.935164        0.319091  ...  7.795831e-02  1.195217e-01\n## 11304      1344.515458        0.397116  ...  9.764703e-03  1.865793e-02\n## 11305       295.742823       -5.521131  ...  1.947981e-77  1.213967e-75\n## 11306      2356.502410       -0.791075  ...  3.972588e-07  1.463156e-06\n## ...                ...             ...  ...           ...           ...\n## 100862251   838.908288        0.128801  ...  6.241817e-01  6.960756e-01\n## 100862257  1041.025804        0.187428  ...  4.008521e-01  4.868171e-01\n## 100862258  1534.037447        0.143802  ...  5.059068e-01  5.888641e-01\n## 100862307   369.536157        0.047139  ...  8.487170e-01  8.857512e-01\n## 100862400   855.267041       -0.072764  ...  7.580740e-01  8.120299e-01\n## \n## [13274 rows x 6 columns]\n\nbasal_vs_lp_res = basal_vs_lp.results_df\nbasal_vs_ml.summary()\n\n## Running Wald tests...\n## ... done in 0.35 seconds.\n## \n## Log2 fold change & Wald test p-value: group Basal vs ML\n##               baseMean  log2FoldChange  ...        pvalue          padj\n## 11302       782.020723        0.125763  ...  5.822965e-01  6.564249e-01\n## 11303      1651.935164       -0.310793  ...  8.461658e-02  1.275209e-01\n## 11304      1344.515458        0.460100  ...  2.679736e-03  5.633643e-03\n## 11305       295.742823       -5.023438  ...  2.219609e-64  8.299461e-63\n## 11306      2356.502410       -0.979360  ...  3.187953e-10  1.490556e-09\n## ...                ...             ...  ...           ...           ...\n## 100862251   838.908288        0.708760  ...  7.059043e-03  1.372517e-02\n## 100862257  1041.025804       -1.106419  ...  5.835175e-07  2.015512e-06\n## 100862258  1534.037447        0.310210  ...  1.509529e-01  2.109996e-01\n## 100862307   369.536157       -0.459937  ...  6.060102e-02  9.521993e-02\n## 100862400   855.267041        0.166803  ...  4.797587e-01  5.609369e-01\n## \n## [13274 rows x 6 columns]\n\nbasal_vs_ml_res = basal_vs_ml.results_df\n\n\n4.4.1 Add gene names\n\n## Add the genes information\nres = res.merge(dds.var,left_index=True,right_index=True)\nbasal_vs_lp_res = basal_vs_lp_res.merge(dds.var,left_index=True,right_index=True)\nbasal_vs_ml_res = basal_vs_ml_res.merge(dds.var,left_index=True,right_index=True)\n\n## Sort by adjusted p-value\nbasal_vs_lp_res = basal_vs_lp_res.sort_values(by='padj', ascending=True)\nbasal_vs_ml_res = basal_vs_ml_res.sort_values(by='padj', ascending=True)\n\n\n\n4.4.2 Exploring results\nMA-plot\n\n## MA-plot\nplt.figure(figsize=(8, 6))\nsns.scatterplot(\n    x=res[\"baseMean\"],\n    y=res[\"log2FoldChange\"],\n    hue=res[\"padj\"] &lt; 0.05,  # Highlight significant points\n    palette={True: \"blue\", False: \"gray\"},\n    alpha=0.6,\n)\nplt.axhline(0, color=\"black\", linestyle=\"--\", linewidth=1)\nplt.xscale(\"log\")\nplt.xlabel(\"Mean Normalized Counts\")\nplt.ylabel(\"Log2 Fold Change\")\nplt.title(\"MA Plot\")\nplt.legend(title=\"Significant\", labels=[\"Yes\", \"No\"])\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nPCA\n\nsc.tl.pca(dds)\n\n## Group PCA\nsc.pl.pca(dds, color='group', size=200, annotate_var_explained=True,legend_loc='best', show=True)\n\n\n\n\n\n\n\n## Lane PCA\nsc.pl.pca(dds, color='lane', size=200, annotate_var_explained=True,legend_loc='best', show=True)\n\n\n\n\n\n\n\n\nVolcano plot\n\n## Basal vs. LP volcano plot\nvolcano(\n    basal_vs_lp_res,\n    symbol = 'SYMBOL',\n    to_label= 30,\n    pval_thresh = 0.05,\n    log2fc_thresh = 2.5)\n\n## 0s encountered for p value, imputing 1e-323\n## impute your own value if you want to avoid this\n\n\n\n\n\n\n\n\n    \n## Basal vs. LP volcano plot\nvolcano(\n    basal_vs_lp_res,\n    symbol = 'SYMBOL',\n    to_label= 30,\n    pval_thresh = 0.05,\n    log2fc_thresh = 2.5)\n\n## 0s encountered for p value, imputing 1e-323\n## impute your own value if you want to avoid this\n\n\n\n\n\n\n\n\n\nHeatmap\n\n## Extract the top genes\nbasal_vs_lp_topgenes = basal_vs_lp_res.ENTREZID[0:100]\nbasal_vs_ml_topgenes = basal_vs_ml_res.ENTREZID[0:100]\n\n## Add log transformation counts\ndds.layers['log1p'] = np.log1p(dds.layers['normed_counts'])\n\n## Get index from significant genes\nbasalvslp_sigs = dds[:, basal_vs_lp_topgenes]\nbasalvsml_sigs = dds[:, basal_vs_ml_topgenes]\n\n## Create counts matrices\ngrapher_blp = pd.DataFrame(\n    basalvslp_sigs.layers['log1p'].T,\n    index=basalvslp_sigs.var_names,\n    columns=basalvslp_sigs.obs_names)\n\ngrapher_bml = pd.DataFrame(\n    basalvsml_sigs.layers['log1p'].T,\n    index=basalvsml_sigs.var_names,\n    columns=basalvsml_sigs.obs_names)\n\n## Define color palette\nhmap_palette = sns.diverging_palette(10, 250, as_cmap=True)\n\n## Heatmap for Basal vs. LP\nsns.clustermap(grapher_blp,\n               z_score=0,\n               cmap=hmap_palette,\n               col_cluster=True,\n               row_cluster=True,\n               xticklabels=metadata.group[grapher_bml.columns].to_list(),\n               yticklabels=basal_vs_lp_res.SYMBOL[basal_vs_lp_topgenes].to_list()).fig.suptitle('Basal vs. LP') \n\nplt.show()\n\n\n\n\n\n\n\n## Heatmap for Basal vs. ML\nsns.clustermap(grapher_bml,\n               z_score=0,\n               cmap=hmap_palette,\n               col_cluster=True,\n               row_cluster=True,\n               xticklabels=metadata.group[grapher_bml.columns],\n               yticklabels=basal_vs_ml_res.SYMBOL[basal_vs_ml_topgenes].to_list()).fig.suptitle('Basal vs. ML') \n\nplt.show()",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Análisis de Expresión Diferencial</span>"
    ]
  },
  {
    "objectID": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#comparación",
    "href": "chapters/Clase7_AnalisisDeExpresionDiferencial.html#comparación",
    "title": "Análisis de Expresión Diferencial I",
    "section": "5. Comparación",
    "text": "5. Comparación\n\n5.1 edgeR\n\nMétodo principal:\nUtiliza modelos lineales generalizados (GLM) basados en la distribución binomial negativa.\nNormalización:\nRealiza la normalización utilizando el método de la media recortada ponderada de la razón (TMM). Este método ajusta los efectos de composición entre muestras.\nEstadísticas diferenciales:\nEstima la dispersión biológica para cada gen y utiliza un enfoque Bayesiano empírico para estabilizar estas estimaciones, mejorando la precisión en experimentos con pocos replicados.\nCasos de uso:\n\nIdeal para datos con pocas réplicas biológicas.\nMuy robusto frente a variaciones en la profundidad de secuenciación.\n\n\n\n\n5.2 DESeq2\n\nMétodo principal:\nBasado en la distribución binomial negativa, modela los datos de conteo utilizando un enfoque de regresión GLM, similar a edgeR. Sin embargo, DESeq2 implementa un procedimiento más detallado para la estimación de dispersión.\nNormalización:\nUtiliza el método de razón geométrica para calcular factores de escala, que corrigen las diferencias de tamaño de biblioteca entre muestras.\nEstadísticas diferenciales:\n\nEstima la dispersión utilizando un modelo empírico y luego ajusta estos valores utilizando un enfoque Bayesiano para estabilizar las varianzas.\nImplementa un procedimiento de “shrinkage” para los coeficientes del modelo, lo que mejora la robustez en genes de baja expresión.\n\nCasos de uso:\n\nPreferido para datos con un número moderado a grande de réplicas.\nMejora la detección de genes diferencialmente expresados con bajos conteos.\n\n\n\n\n5.3 pyDESeq2\n\nMétodo principal:\nEs una implementación en Python basada en DESeq2. Internamente utiliza las mismas bases teóricas y estadísticas, ya que está diseñado para ofrecer la misma funcionalidad en un entorno Python.\nNormalización y estadística:\n\nReproduce la normalización basada en razones geométricas y los modelos de regresión GLM con dispersión ajustada Bayesiana.\nLa diferencia clave está en que facilita la integración con bibliotecas y pipelines en Python, como pandas y scikit-learn.\n\nCasos de uso:\n\nIdeal para usuarios que trabajan en ecosistemas Python y no desean depender de R.\nÚtil en pipelines integrados con otras herramientas de aprendizaje automático o análisis avanzado.\n\n\n\n\n5.4 Resumen\n\n\n\n\n\n\n\n\n\nAspecto\nedgeR\nDESeq2\npyDESeq2\n\n\n\n\nBase estadística\nBinomial negativa + GLM\nBinomial negativa + GLM\nIgual que DESeq2\n\n\nNormalización\nTMM\nRazón geométrica\nIgual que DESeq2\n\n\nAjuste Bayesiano\nSí (dispersión)\nSí (dispersión y shrinkage)\nIgual que DESeq2\n\n\nFacilidad de uso\nR\nR\nPython\n\n\nCasos recomendados\nPocas réplicas\nRéplicas moderadas o altas\nUsuarios de Python\n\n\n\n\n\n5.5 Resultados obtenidos\nHay que recordar que pyDESeq2 es una librería emergente que trata de implementar la librería original de R DESeq2 en Python. Los resultados muestran una similitud de 86 y 84 genes cuando se comparan las librerías de R DESeq2 y edgeR mientras que se encuentra sólo 1 gen compartido con los resultados de pyDESeq2. Esto mayormente puede deberse a la implementación dada. Sin embargo, no hay que descartar que esten ahí hasta una posterior confirmación (probablemente sólo estén rankeados diferente). Por eso la recomendación es que se sigan usando las librerías de R hasta que se logre hacer una transición completa a Python en términos del análisis transcriptómico.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Análisis de Expresión Diferencial</span>"
    ]
  },
  {
    "objectID": "chapters/Clase8_AnotacionFuncional.html",
    "href": "chapters/Clase8_AnotacionFuncional.html",
    "title": "Anotación Funcional",
    "section": "",
    "text": "1. Análisis funcional\nUn análisis de expresión documental deja como resultado a los genes diferencialmente expresados en la comparación de dos o más condiciones. Sin embargo, se necesita asignarles un significado biológico que explique el fenotipo de interés. Para ello se puede hacer lo siguiente:\nExisten múltiples herramientas que dpeenden de diferentes técnicas y se pueden categorizar en tres diferentes tipos principales como sobre-representación, scoring de la clase funcional y topología de vías.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Anotación Funcional</span>"
    ]
  },
  {
    "objectID": "chapters/Clase8_AnotacionFuncional.html#análisis-funcional",
    "href": "chapters/Clase8_AnotacionFuncional.html#análisis-funcional",
    "title": "Anotación Funcional",
    "section": "",
    "text": "Determinar si hay algún enriquecimiento de funciones biológicas, interacciones o vías de señalización conocidas.\nIdentificar genes implicados en nuevas vías y redes mediante la agrupación de genes basado en sus tendencias.\nUso de cambios globales de expresión génica en el contexto de interacción con datos externos.\n\n\n\n1.1 Análisis de sobre-representación\nLas bases de datos de las herramientas que siguen este principio contienen información de la función del gen y sus interacciones. Estas bases de datos categorizan a los genes en grupos (gene sets) basados en una función, vía o presencia en una ubicación celular específica compartida.\nPara determinar si los genes están sobre-representados o no, se calcula la probabilidad de tener una proporción observada de genes pertenecientes a una categoría específica basada en la proporción de genes asociados a la misma categoría en un set de genes de referencia.\n\n\n\n\n\n\n\n\n\nGenes categories\nOrganism-specific Background\nDE results\nOver-represented?\n\n\n\n\nFunctional category 1\n35/13000\n25/1000\nLikely\n\n\nFunctional category 2\n56/13000\n4/1000\nUnlikely\n\n\nFunctional category 3\n90/13000\n8/1000\nUnlikely\n\n\nFunctional category 4\n15/13000\n10/1000\nLikely\n\n\n…\n…\n…\n…\n\n\n\nLa prueba estadística que va a determinar si algo esta sobre-representado o no es la prueba hipergeométrica.\n\n1.1.1 Prueba hipergeométrica\nUna distribución hipergeométrica describe la probabilidad de que 25 genes (k) estén asociados con la “Categoría funcional 1”, para todos los genes en nuestra lista de genes (n = 1000), de una población de todos los genes del genoma (N = 13,000) el cual contiene 35 genes (K) asociados con la “Categoría funcional 1”.\nPara el cálculo de la probabilidad es la siguiente fórmula:\n\\[\nP(X = k) = \\frac{\\binom{K}{k} \\binom{N-K}{n-k}}{\\binom{N}{n}}\n\\]\n\\[\nP(X = 25) = \\frac{\\binom{35}{25} \\binom{13,000-35}{1000-25}}{\\binom{13,000}{1000}}\n\\]\nEsta prueba resulta en un p-value ajustado para cada categoría probada. De aquí resulta el Gene Ontology project.\n\n\n1.1.2 Gene Ontology project\nLa categorización más usada es Gene Ontology (GO) la cual consiste en la categorización consistente de los productos de los genes a lo largo de las bases de datos. Para esto, los términos GO se organizan en 3 categorías independientes:\n\nProcesos biológicos\nFunción molecular\nComponente celular\n\nExisten múltiples herramientas que son capaces de hacer Gene Ontologies:\n\nDAVID (https://davidbioinformatics.nih.gov/)\nEnrichr (https://maayanlab.cloud/Enrichr/)\nShinyGO (https://bioinformatics.sdstate.edu/go/)\nGOstat (R)\nclusterProfiler (R)\ntopGO (R)\n\nA continuación vamos a revisar las 3 diferentes librerías de R\n\n\n1.1.3 clusterProfiler\nFunciona mejor con los Ensembl IDs.\nInstall libraries\n\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\", quiet = TRUE)\n\nif (!require(DOSE, quietly = TRUE))\n    BiocManager::install(\"DOSE\",quiet = TRUE)\nif (!require(pathview, quietly = TRUE))\n    BiocManager::install(\"pathview\",quiet = TRUE)\nif (!require(clusterProfiler, quietly = TRUE))\n    BiocManager::install(\"clusterProfiler\",quiet = TRUE)\n\nLoad libraries\n\n## Load libraries\nlibrary(DOSE)\nlibrary(pathview)\nlibrary(clusterProfiler)\nlibrary(AnnotationHub)\nlibrary(GenomicFeatures)\nlibrary(org.Mm.eg.db)\nlibrary(enrichplot)\n\nExtract DEG’s\n\n5xFAD_female_cortex_12mon vs. WT_female_cortex_12mon\n\n\n## Load DEG's\ncomparison &lt;- dds_list[[\"5xFADfemalecortex12mon_VS_WTfemalecortex12mon\"]]\n\n## Extract the 100 top genes\ngenes &lt;- comparison$`100topgenes`\n\nMerge Annotation with DEG’s\n\n## Extract genes\nannotations &lt;- AnnotationDbi::select(org.Mm.eg.db,\n                                     keys = genes,\n                                     columns = c(\"ENSEMBL\",\"SYMBOL\",\"ENTREZID\",\"GO\"),\n                                     keytype = \"ENSEMBL\")\n\nRun clusterProfiler\n\n## Run GO enrichment analysis \nego &lt;- enrichGO(gene = as.character(genes), \n                universe = as.character(rownames(comparison$result_ful)),\n                keyType = \"ENSEMBL\",\n                OrgDb = org.Mm.eg.db, \n                ont = \"BP\", \n                pAdjustMethod = \"BH\", \n                qvalueCutoff = 0.05, \n                readable = TRUE)\n\n## Generate the summary\ncluster_summary &lt;- data.frame(ego)\nhead(cluster_summary)\n\n\n  \n\n\n\nVisualizing results\n\nbarplot\n\n\n## Barplot\nbarplot(ego,\n        showCategory = 50,\n        font.size = 6,\n        label_format = 65)\n\n\n\n\n\n\n\n\n\ndotplot\n\n\n## Dotplot\ndotplot(ego,\n        showCategory=50,\n        font.size = 6,\n        label_format = 65)\n\n\n\n\n\n\n\n\n\nenrichment GO plot\n\n\n## enrichment GO plot\nego &lt;- enrichplot::pairwise_termsim(ego)\nemapplot(ego,\n         showCategory = 50)\n\n\n\n\n\n\n\n\n\nNet plot\n\n\n## cnet plot\nsig.degs &lt;- as.data.frame(comparison$result_sig[1:100,])\ndegs.lfc &lt;- sig.degs$log2FoldChange\nnames(degs.lfc) &lt;- rownames(sig.degs)\ncnetplot(ego,\n         categorySize = \"pvalue\",\n         showCategory = 10,\n         foldChange = degs.lfc,\n         vertex.label.font = 6)\n\n\n\n\n\n\n\n\n\nHeatmap-like plot\n\n\n## Heatmap-like plot\nheatplot(ego,\n         foldChange = degs.lfc,\n         showCategory = 5) +\n    ggplot2::scale_color_manual(RColorBrewer::brewer.pal(11, \"RdBu\"))\n\n\n\n\n\n\n\n\n\nTree plot\n\n\n## Tree plot\nego2 &lt;- enrichplot::pairwise_termsim(ego)\ntreeplot(ego2, hclust_method = \"average\")\n\n\n\n\n\n\n\n\n\n\n\n1.2 Scoring de clases funcionales\nFunctional class scoring (FCS) como GSEA (Gene Set Enrichment Analysis) usan la estadística a nivel de genes o los log2 fold changes para todos los genes diferencialmente expresados. Después se revisa si diferentes vías biológicas están enriquecidas entre los diferentes fold changes.\nLa hipótesis que siguen es que no sólo se consideran los genes siginificativos por su efecto individual, sino todos los genes porque en conjunto pueden tener un efecto pobre pero coordinado por su compartir vías y funcionalidad.\nPara esto también se puede usar clusterProfiler y funciona mejor si se trabaja con Entrez IDs.\n\n1.2.1 GSEA\nEl Análisis de Enriquecimiento de Conjuntos de Genes (GSEA, por sus siglas en inglés) es un método utilizado para determinar si un conjunto de genes muestra diferencias estadísticamente significativas entre dos estados biológicos. Se usa con frecuencia para identificar rutas, conjuntos de genes o anotaciones funcionales que están enriquecidos en un conjunto específico de genes, generalmente derivados de datos de RNA-seq, datos de microarrays u otros datos ómicos.\n\n\n1.2.2 clusterProfiler\nExtract the Entrez IDs from the whole DEA result\n\n## Extract DEA results\ndea.res &lt;- as.data.frame(comparison$result_sig)\ndea.res.genes &lt;- rownames(dea.res)\n\nExtract annotations\n\n## Retrieve annotations\nannotations &lt;- AnnotationDbi::select(org.Mm.eg.db,\n                                     keys = dea.res.genes,\n                                     columns = c(\"ENSEMBL\",\"SYMBOL\",\"ENTREZID\"),\n                                     keytype = \"ENSEMBL\")\n\nannotations &lt;- annotations[!duplicated(annotations$ENSEMBL),]\nrownames(annotations) &lt;- annotations$ENSEMBL\n\ndea.res &lt;- merge(dea.res,annotations,by = \"row.names\",all = TRUE)\nrownames(dea.res) &lt;- dea.res$ENSEMBL\n\n## Extract Entrez IDs\nentrez.ids &lt;- dea.res$ENTREZID\nnames(entrez.ids) &lt;- rownames(dea.res)\nentrez.ids &lt;- entrez.ids[!duplicated(entrez.ids)]\n\nExtract fold changes\n\n## Extract fold-changes\ndea.res.lfc &lt;- dea.res$log2FoldChange\nnames(dea.res.lfc) &lt;- dea.res$ENTREZID\ndea.res.lfc &lt;- dea.res.lfc[entrez.ids]\ndea.res.lfc &lt;- sort(dea.res.lfc,decreasing = TRUE)\n\n\n\n1.2.3 KEGG gene sets\n\n## GSEA using KEGG\ngseaKEGG &lt;- gseKEGG(geneList = dea.res.lfc,\n                    organism = \"mmu\",\n                    nPerm = 1000,\n                    minGSSize = 20,\n                    pvalueCutoff = 0.05,\n                    verbose = FALSE)\n\n## Extract results\ngseaKEGG.res &lt;- gseaKEGG@result\n\nExplore GSEA results\n\nGSEA plot\n\n\n## GSEA plot for phagosome\ngseaplot(gseaKEGG, geneSetID = \"mmu04145\")\n\n\n\n\n\n\n\n\n\nPathway\n\n\n## Pathway\npathview(gene.data = dea.res.lfc,\n         pathway.id = \"mmu04145\",\n         species = \"mmu\",\n         limit = list(gene = 2,\n                      cpd = 1))\n\n\n\ndotplot\n\n\ndotplot(gseaKEGG,\n        color = \"pvalue\",\n        showCategory=50,\n        font.size = 10,\n        label_format = 65)\n\n\n\n\n\n\n\n\n\nridgeplot\n\n\n## ridgeplot\nridgeplot(gseaKEGG,\n          showCategory = 50,\n          fill = \"pvalue\")\n\n\n\n\n\n\n\n\n\nmultiple GSEA plot\n\n\n## multiple GSEA plots\ngseaplot2(gseaKEGG, geneSetID = 1:5)\n\n\n\n\n\n\n\n\n\n\n1.2.4 KEGG with Gene Ontology\n\n## GSEA with KEGG database and Gene Ontology terms\ngseaGO &lt;- gseGO(geneList = dea.res.lfc,\n                OrgDb = org.Mm.eg.db,\n                ont = \"BP\",\n                nPerm = 1000,\n                minGSSize = 20,\n                pvalueCutoff = 0.05,\n                verbose = FALSE)\n\n## Extract results\ngseaGO.res &lt;- gseaGO@result\n\nExplore GSEA results\n\nGSEA plot\n\n\n## GSEA plot for immune response\ngseaplot(gseaGO, geneSetID = \"GO:0002376\")\n\n\n\n\n\n\n\n\n\ndotplot\n\n\ndotplot(gseaGO,\n        color = \"pvalue\",\n        showCategory=50,\n        font.size = 6,\n        label_format = 65)\n\n\n\n\n\n\n\n\n\nridgeplot\n\n\n## ridgeplot\nridgeplot(gseaGO,\n          showCategory = 50,\n          fill = \"pvalue\")\n\n\n\n\n\n\n\n\n\nGSEA plot\n\n\n## multiple GSEA plots\ngseaplot2(gseaGO, geneSetID = 1:5)\n\n\n\n\n\n\n\n\n\n\n\n1.3 Análisis de topología\nEl último tipo principal de técnica de análisis funcional es el análisis de topología de rutas (pathway topology analysis). Este análisis considera la información sobre la interacción genética junto con los cambios de pliegue (fold changes) y los valores p ajustados provenientes del análisis de expresión diferencial para identificar rutas disfuncionales. Dependiendo de la herramienta utilizada, los métodos de topología de rutas exploran cómo los genes interactúan entre sí (por ejemplo, activación, inhibición, fosforilación, ubiquitinación, etc.) para determinar las estadísticas a nivel de ruta. Estos métodos utilizan el número y tipo de interacciones entre los productos génicos (nuestros genes diferencialmente expresados) y otros productos génicos para inferir la función génica o la asociación con rutas.\n\n1.3.1 SPIA (Signaling Pathway Impact Analysis)\nFunciona mejor con Entrez IDs\n\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\", quiet = TRUE)\n\nif (!require(SPIA, quietly = TRUE))\n    BiocManager::install(\"SPIA\",quiet = TRUE)\n\nLoad libraries\n\nlibrary(SPIA)\n\nExtract the significant genes\n\n## Significant genes\ndea.res.all &lt;- as.data.frame(comparison$result_ful)\ndea.genes.all &lt;- rownames(dea.res.all)\n\nRetrieve annotations\n\n## Retrieve annotations\nannotations &lt;- AnnotationDbi::select(org.Mm.eg.db,\n                                     keys = dea.genes.all,\n                                     columns = c(\"ENSEMBL\",\"SYMBOL\",\"ENTREZID\"),\n                                     keytype = \"ENSEMBL\")\n\nannotations &lt;- annotations[!duplicated(annotations$ENSEMBL),]\nrownames(annotations) &lt;- annotations$ENSEMBL\n\ndea.res.all &lt;- merge(dea.res.all,annotations,by = \"row.names\",all = TRUE)\nrownames(dea.res.all) &lt;- dea.res.all$ENSEMBL\n\n## Extract Entrez IDs\nentrez.ids.all &lt;- dea.res.all$ENTREZID\nnames(entrez.ids.all) &lt;- rownames(dea.res.all)\nentrez.ids.all &lt;- entrez.ids.all[!duplicated(entrez.ids.all)]\n\nExtract fold changes\n\n## Extract fold-changes\ndea.res.all.lfc &lt;- dea.res.all$log2FoldChange\nnames(dea.res.all.lfc) &lt;- dea.res.all$ENTREZID\ndea.res.all.lfc &lt;- dea.res.all.lfc[entrez.ids.all]\ndea.res.all.lfc &lt;- sort(dea.res.all.lfc,decreasing = TRUE)\n\nrun SPIA\n\n## run SPIA\nspia.res &lt;- spia(de = dea.res.lfc,\n                 all = entrez.ids.all,\n                 organism = \"mmu\")\n\n## \n## Done pathway 1 : RNA transport..\n## Done pathway 2 : RNA degradation..\n## Done pathway 3 : PPAR signaling pathway..\n## Done pathway 4 : Fanconi anemia pathway..\n## Done pathway 5 : MAPK signaling pathway..\n## Done pathway 6 : ErbB signaling pathway..\n## Done pathway 7 : Calcium signaling pathway..\n## Done pathway 8 : Cytokine-cytokine receptor int..\n## Done pathway 9 : Chemokine signaling pathway..\n## Done pathway 10 : NF-kappa B signaling pathway..\n## Done pathway 11 : Phosphatidylinositol signaling..\n## Done pathway 12 : Neuroactive ligand-receptor in..\n## Done pathway 13 : Cell cycle..\n## Done pathway 14 : Oocyte meiosis..\n## Done pathway 15 : p53 signaling pathway..\n## Done pathway 16 : Sulfur relay system..\n## Done pathway 17 : SNARE interactions in vesicula..\n## Done pathway 18 : Regulation of autophagy..\n## Done pathway 19 : Protein processing in endoplas..\n## Done pathway 20 : Lysosome..\n## Done pathway 21 : mTOR signaling pathway..\n## Done pathway 22 : Apoptosis..\n## Done pathway 23 : Vascular smooth muscle contrac..\n## Done pathway 24 : Wnt signaling pathway..\n## Done pathway 25 : Dorso-ventral axis formation..\n## Done pathway 26 : Notch signaling pathway..\n## Done pathway 27 : Hedgehog signaling pathway..\n## Done pathway 28 : TGF-beta signaling pathway..\n## Done pathway 29 : Axon guidance..\n## Done pathway 30 : VEGF signaling pathway..\n## Done pathway 31 : Osteoclast differentiation..\n## Done pathway 32 : Focal adhesion..\n## Done pathway 33 : ECM-receptor interaction..\n## Done pathway 34 : Cell adhesion molecules (CAMs)..\n## Done pathway 35 : Adherens junction..\n## Done pathway 36 : Tight junction..\n## Done pathway 37 : Gap junction..\n## Done pathway 38 : Complement and coagulation cas..\n## Done pathway 39 : Antigen processing and present..\n## Done pathway 40 : Toll-like receptor signaling p..\n## Done pathway 41 : NOD-like receptor signaling pa..\n## Done pathway 42 : RIG-I-like receptor signaling ..\n## Done pathway 43 : Cytosolic DNA-sensing pathway..\n## Done pathway 44 : Jak-STAT signaling pathway..\n## Done pathway 45 : Natural killer cell mediated c..\n## Done pathway 46 : T cell receptor signaling path..\n## Done pathway 47 : B cell receptor signaling path..\n## Done pathway 48 : Fc epsilon RI signaling pathwa..\n## Done pathway 49 : Fc gamma R-mediated phagocytos..\n## Done pathway 50 : Leukocyte transendothelial mig..\n## Done pathway 51 : Intestinal immune network for ..\n## Done pathway 52 : Circadian rhythm - mammal..\n## Done pathway 53 : Long-term potentiation..\n## Done pathway 54 : Neurotrophin signaling pathway..\n## Done pathway 55 : Retrograde endocannabinoid sig..\n## Done pathway 56 : Glutamatergic synapse..\n## Done pathway 57 : Cholinergic synapse..\n## Done pathway 58 : Serotonergic synapse..\n## Done pathway 59 : GABAergic synapse..\n## Done pathway 60 : Dopaminergic synapse..\n## Done pathway 61 : Long-term depression..\n## Done pathway 62 : Olfactory transduction..\n## Done pathway 63 : Taste transduction..\n## Done pathway 64 : Phototransduction..\n## Done pathway 65 : Regulation of actin cytoskelet..\n## Done pathway 66 : Insulin signaling pathway..\n## Done pathway 67 : GnRH signaling pathway..\n## Done pathway 68 : Progesterone-mediated oocyte m..\n## Done pathway 69 : Melanogenesis..\n## Done pathway 70 : Adipocytokine signaling pathwa..\n## Done pathway 71 : Type II diabetes mellitus..\n## Done pathway 72 : Type I diabetes mellitus..\n## Done pathway 73 : Maturity onset diabetes of the..\n## Done pathway 74 : Aldosterone-regulated sodium r..\n## Done pathway 75 : Endocrine and other factor-reg..\n## Done pathway 76 : Vasopressin-regulated water re..\n## Done pathway 77 : Salivary secretion..\n## Done pathway 78 : Gastric acid secretion..\n## Done pathway 79 : Pancreatic secretion..\n## Done pathway 80 : Carbohydrate digestion and abs..\n## Done pathway 81 : Bile secretion..\n## Done pathway 82 : Mineral absorption..\n## Done pathway 83 : Alzheimer's disease..\n## Done pathway 84 : Parkinson's disease..\n## Done pathway 85 : Amyotrophic lateral sclerosis ..\n## Done pathway 86 : Huntington's disease..\n## Done pathway 87 : Prion diseases..\n## Done pathway 88 : Cocaine addiction..\n## Done pathway 89 : Amphetamine addiction..\n## Done pathway 90 : Morphine addiction..\n## Done pathway 91 : Alcoholism..\n## Done pathway 92 : Bacterial invasion of epitheli..\n## Done pathway 93 : Salmonella infection..\n## Done pathway 94 : Pertussis..\n## Done pathway 95 : Legionellosis..\n## Done pathway 96 : Leishmaniasis..\n## Done pathway 97 : Chagas disease (American trypa..\n## Done pathway 98 : African trypanosomiasis..\n## Done pathway 99 : Malaria..\n## Done pathway 100 : Toxoplasmosis..\n## Done pathway 101 : Amoebiasis..\n## Done pathway 102 : Staphylococcus aureus infectio..\n## Done pathway 103 : Tuberculosis..\n## Done pathway 104 : Hepatitis C..\n## Done pathway 105 : Measles..\n## Done pathway 106 : Influenza A..\n## Done pathway 107 : HTLV-I infection..\n## Done pathway 108 : Herpes simplex infection..\n## Done pathway 109 : Epstein-Barr virus infection..\n## Done pathway 110 : Pathways in cancer..\n## Done pathway 111 : Transcriptional misregulation ..\n## Done pathway 112 : Viral carcinogenesis..\n## Done pathway 113 : Colorectal cancer..\n## Done pathway 114 : Renal cell carcinoma..\n## Done pathway 115 : Pancreatic cancer..\n## Done pathway 116 : Endometrial cancer..\n## Done pathway 117 : Glioma..\n## Done pathway 118 : Prostate cancer..\n## Done pathway 119 : Thyroid cancer..\n## Done pathway 120 : Basal cell carcinoma..\n## Done pathway 121 : Melanoma..\n## Done pathway 122 : Bladder cancer..\n## Done pathway 123 : Chronic myeloid leukemia..\n## Done pathway 124 : Acute myeloid leukemia..\n## Done pathway 125 : Small cell lung cancer..\n## Done pathway 126 : Non-small cell lung cancer..\n## Done pathway 127 : Asthma..\n## Done pathway 128 : Autoimmune thyroid disease..\n## Done pathway 129 : Systemic lupus erythematosus..\n## Done pathway 130 : Rheumatoid arthritis..\n## Done pathway 131 : Allograft rejection..\n## Done pathway 132 : Graft-versus-host disease..\n## Done pathway 133 : Arrhythmogenic right ventricul..\n## Done pathway 134 : Dilated cardiomyopathy..\n## Done pathway 135 : Viral myocarditis..\n\nspia.res &lt;- spia.res[complete.cases(spia.res),]\n\n## Explore outputs\nhead(spia.res, n=10)\n\n\n  \n\n\n\nExplore results\n\nTwo-way evidence plot\n\n\nplotP(spia.res,threshold = 0.05)",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Anotación Funcional</span>"
    ]
  },
  {
    "objectID": "chapters/Clase8_AnotacionFuncional.html#reproducibilidad",
    "href": "chapters/Clase8_AnotacionFuncional.html#reproducibilidad",
    "title": "Anotación Funcional",
    "section": "Reproducibilidad",
    "text": "Reproducibilidad\n\n\n## ─ Session info ───────────────────────────────────────────────────────────────\n##  setting  value\n##  version  R version 4.4.2 (2024-10-31 ucrt)\n##  os       Windows 11 x64 (build 26100)\n##  system   x86_64, mingw32\n##  ui       RTerm\n##  language (EN)\n##  collate  English_United States.utf8\n##  ctype    English_United States.utf8\n##  tz       America/Mexico_City\n##  date     2025-01-21\n##  pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n## \n## ─ Packages ───────────────────────────────────────────────────────────────────\n##  package              * version   date (UTC) lib source\n##  abind                  1.4-8     2024-09-12 [1] CRAN (R 4.4.1)\n##  AnnotationDbi        * 1.68.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  AnnotationHub        * 3.14.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  ape                    5.8-1     2024-12-16 [1] CRAN (R 4.4.2)\n##  aplot                  0.2.4     2024-12-17 [1] CRAN (R 4.4.2)\n##  Biobase              * 2.66.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  BiocFileCache        * 2.14.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  BiocGenerics         * 0.52.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  BiocIO                 1.16.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  BiocManager            1.30.25   2024-08-28 [1] CRAN (R 4.4.2)\n##  BiocParallel           1.40.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  BiocVersion            3.20.0    2024-10-21 [1] Bioconductor 3.20 (R 4.4.1)\n##  Biostrings             2.74.1    2024-12-16 [1] Bioconductor 3.20 (R 4.4.2)\n##  bit                    4.5.0.1   2024-12-03 [1] CRAN (R 4.4.2)\n##  bit64                  4.5.2     2024-09-22 [1] CRAN (R 4.4.2)\n##  bitops                 1.0-9     2024-10-03 [1] CRAN (R 4.4.1)\n##  blob                   1.2.4     2023-03-17 [1] CRAN (R 4.4.2)\n##  cachem                 1.1.0     2024-05-16 [1] CRAN (R 4.4.2)\n##  cli                    3.6.3     2024-06-21 [1] CRAN (R 4.4.2)\n##  clusterProfiler      * 4.14.4    2024-12-02 [1] Bioconductor 3.20 (R 4.4.2)\n##  codetools              0.2-20    2024-03-31 [2] CRAN (R 4.4.2)\n##  colorspace             2.1-1     2024-07-26 [1] CRAN (R 4.4.2)\n##  cowplot                1.1.3     2024-01-22 [1] CRAN (R 4.4.2)\n##  crayon                 1.5.3     2024-06-20 [1] CRAN (R 4.4.2)\n##  curl                   6.0.1     2024-11-14 [1] CRAN (R 4.4.2)\n##  data.table             1.16.4    2024-12-06 [1] CRAN (R 4.4.2)\n##  DBI                    1.2.3     2024-06-02 [1] CRAN (R 4.4.2)\n##  dbplyr               * 2.5.0     2024-03-19 [1] CRAN (R 4.4.2)\n##  DelayedArray           0.32.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  DESeq2                 1.46.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  digest                 0.6.37    2024-08-19 [1] CRAN (R 4.4.2)\n##  DOSE                 * 4.0.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  dplyr                  1.1.4     2023-11-17 [1] CRAN (R 4.4.2)\n##  enrichplot           * 1.26.5    2024-12-12 [1] Bioconductor 3.20 (R 4.4.2)\n##  evaluate               1.0.1     2024-10-10 [1] CRAN (R 4.4.2)\n##  farver                 2.1.2     2024-05-13 [1] CRAN (R 4.4.2)\n##  fastmap                1.2.0     2024-05-15 [1] CRAN (R 4.4.2)\n##  fastmatch              1.1-4     2023-08-18 [1] CRAN (R 4.4.0)\n##  fgsea                  1.32.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  filelock               1.0.3     2023-12-11 [1] CRAN (R 4.4.2)\n##  fs                     1.6.5     2024-10-30 [1] CRAN (R 4.4.2)\n##  generics               0.1.3     2022-07-05 [1] CRAN (R 4.4.2)\n##  GenomeInfoDb         * 1.42.1    2024-11-28 [1] Bioconductor 3.20 (R 4.4.2)\n##  GenomeInfoDbData       1.2.13    2024-12-22 [1] Bioconductor\n##  GenomicAlignments      1.42.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  GenomicFeatures      * 1.58.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  GenomicRanges        * 1.58.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  ggfun                  0.1.8     2024-12-03 [1] CRAN (R 4.4.2)\n##  ggnewscale             0.5.0     2024-07-19 [1] CRAN (R 4.4.2)\n##  ggplot2                3.5.1     2024-04-23 [1] CRAN (R 4.4.2)\n##  ggplotify              0.1.2     2023-08-09 [1] CRAN (R 4.4.2)\n##  ggrepel                0.9.6     2024-09-07 [1] CRAN (R 4.4.2)\n##  ggridges               0.5.6     2024-01-23 [1] CRAN (R 4.4.2)\n##  ggtangle               0.0.6     2024-12-18 [1] CRAN (R 4.4.2)\n##  ggtree                 3.14.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  glue                   1.8.0     2024-09-30 [1] CRAN (R 4.4.2)\n##  GO.db                  3.20.0    2024-12-22 [1] Bioconductor\n##  GOSemSim               2.32.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  graph                  1.84.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  gridGraphics           0.5-1     2020-12-13 [1] CRAN (R 4.4.2)\n##  gson                   0.1.0     2023-03-07 [1] CRAN (R 4.4.2)\n##  gtable                 0.3.6     2024-10-25 [1] CRAN (R 4.4.2)\n##  htmltools              0.5.8.1   2024-04-04 [1] CRAN (R 4.4.2)\n##  htmlwidgets            1.6.4     2023-12-06 [1] CRAN (R 4.4.2)\n##  httr                   1.4.7     2023-08-15 [1] CRAN (R 4.4.2)\n##  igraph                 2.1.2     2024-12-07 [1] CRAN (R 4.4.2)\n##  IRanges              * 2.40.1    2024-12-05 [1] Bioconductor 3.20 (R 4.4.2)\n##  jsonlite               1.8.9     2024-09-20 [1] CRAN (R 4.4.2)\n##  KEGGgraph            * 1.66.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  KEGGREST               1.46.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  knitr                  1.49      2024-11-08 [1] CRAN (R 4.4.2)\n##  labeling               0.4.3     2023-08-29 [1] CRAN (R 4.4.0)\n##  lattice                0.22-6    2024-03-20 [2] CRAN (R 4.4.2)\n##  lazyeval               0.2.2     2019-03-15 [1] CRAN (R 4.4.2)\n##  lifecycle              1.0.4     2023-11-07 [1] CRAN (R 4.4.2)\n##  locfit                 1.5-9.10  2024-06-24 [1] CRAN (R 4.4.2)\n##  magrittr               2.0.3     2022-03-30 [1] CRAN (R 4.4.2)\n##  Matrix                 1.7-1     2024-10-18 [2] CRAN (R 4.4.2)\n##  MatrixGenerics         1.18.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  matrixStats            1.4.1     2024-09-08 [1] CRAN (R 4.4.2)\n##  memoise                2.0.1     2021-11-26 [1] CRAN (R 4.4.2)\n##  munsell                0.5.1     2024-04-01 [1] CRAN (R 4.4.2)\n##  nlme                   3.1-166   2024-08-14 [2] CRAN (R 4.4.2)\n##  org.Hs.eg.db           3.20.0    2024-12-22 [1] Bioconductor\n##  org.Mm.eg.db         * 3.20.0    2024-12-22 [1] Bioconductor\n##  patchwork              1.3.0     2024-09-16 [1] CRAN (R 4.4.2)\n##  pathview             * 1.46.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  pillar                 1.10.0    2024-12-17 [1] CRAN (R 4.4.2)\n##  pkgconfig              2.0.3     2019-09-22 [1] CRAN (R 4.4.2)\n##  plyr                   1.8.9     2023-10-02 [1] CRAN (R 4.4.2)\n##  png                    0.1-8     2022-11-29 [1] CRAN (R 4.4.0)\n##  purrr                  1.0.2     2023-08-10 [1] CRAN (R 4.4.2)\n##  qvalue                 2.38.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  R.methodsS3            1.8.2     2022-06-13 [1] CRAN (R 4.4.0)\n##  R.oo                   1.27.0    2024-11-01 [1] CRAN (R 4.4.1)\n##  R.utils                2.12.3    2023-11-18 [1] CRAN (R 4.4.2)\n##  R6                     2.5.1     2021-08-19 [1] CRAN (R 4.4.2)\n##  rappdirs               0.3.3     2021-01-31 [1] CRAN (R 4.4.2)\n##  RColorBrewer           1.1-3     2022-04-03 [1] CRAN (R 4.4.0)\n##  Rcpp                   1.0.13-1  2024-11-02 [1] CRAN (R 4.4.2)\n##  RCurl                  1.98-1.16 2024-07-11 [1] CRAN (R 4.4.1)\n##  reshape2               1.4.4     2020-04-09 [1] CRAN (R 4.4.2)\n##  restfulr               0.0.15    2022-06-16 [1] CRAN (R 4.4.2)\n##  Rgraphviz              2.50.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  rjson                  0.2.23    2024-09-16 [1] CRAN (R 4.4.1)\n##  rlang                  1.1.4     2024-06-04 [1] CRAN (R 4.4.2)\n##  rmarkdown              2.29      2024-11-04 [1] CRAN (R 4.4.2)\n##  Rsamtools              2.22.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  RSQLite                2.3.9     2024-12-03 [1] CRAN (R 4.4.2)\n##  rstudioapi             0.17.1    2024-10-22 [1] CRAN (R 4.4.2)\n##  rtracklayer            1.66.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  S4Arrays               1.6.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  S4Vectors            * 0.44.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  scales                 1.3.0     2023-11-28 [1] CRAN (R 4.4.2)\n##  sessioninfo            1.2.2     2021-12-06 [1] CRAN (R 4.4.2)\n##  snow                   0.4-4     2021-10-27 [1] CRAN (R 4.4.0)\n##  SparseArray            1.6.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  SPIA                 * 2.58.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  stringi                1.8.4     2024-05-06 [1] CRAN (R 4.4.0)\n##  stringr                1.5.1     2023-11-14 [1] CRAN (R 4.4.2)\n##  SummarizedExperiment   1.36.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  tibble                 3.2.1     2023-03-20 [1] CRAN (R 4.4.2)\n##  tidyr                  1.3.1     2024-01-24 [1] CRAN (R 4.4.2)\n##  tidyselect             1.2.1     2024-03-11 [1] CRAN (R 4.4.2)\n##  tidytree               0.4.6     2023-12-12 [1] CRAN (R 4.4.2)\n##  treeio                 1.30.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  UCSC.utils             1.2.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  vctrs                  0.6.5     2023-12-01 [1] CRAN (R 4.4.2)\n##  withr                  3.0.2     2024-10-28 [1] CRAN (R 4.4.2)\n##  xfun                   0.49      2024-10-31 [1] CRAN (R 4.4.2)\n##  XML                    3.99-0.17 2024-06-25 [1] CRAN (R 4.4.1)\n##  XVector                0.46.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##  yaml                   2.3.10    2024-07-26 [1] CRAN (R 4.4.1)\n##  yulab.utils            0.1.8     2024-11-07 [1] CRAN (R 4.4.2)\n##  zlibbioc               1.52.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n## \n##  [1] C:/Users/chomb/AppData/Local/R/win-library/4.4\n##  [2] C:/Program Files/R/R-4.4.2/library\n## \n## ──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Anotación Funcional</span>"
    ]
  },
  {
    "objectID": "chapters/Clase12_SingleCellRNAseq.html#motivación",
    "href": "chapters/Clase12_SingleCellRNAseq.html#motivación",
    "title": "Single-cell RNA-seq",
    "section": "",
    "text": "1.1 ¿Qué es scRNA-seq?\nEl scRNA-seq (secuenciación de ARN unicelular) es una técnica que permite medir la expresión génica a nivel de células individuales. Esto contrasta con los métodos tradicionales (como el bulk RNA-seq), que miden la expresión como un promedio de todas las células en una muestra.\n\n\n1.2 ¿Para qué sirve?\nscRNA-seq se utiliza para:\n\nIdentificar subpoblaciones celulares en tejidos heterogéneos.\nEstudiar diferencias en la expresión génica entre células individuales.\nInvestigar procesos dinámicos como la diferenciación celular o respuestas al estrés.\nReconstruir trayectorias celulares en tiempo o espacio.\n\n\n\n1.3 Diferencias entre bulk RNA-seq y scRNA-seq\n\n\n\n\n\n\n\n\nCaracterística\nscRNA-seq\nBulk RNA-seq\n\n\n\n\nResolución\nNivel unicelular\nPromedio de todas las células en la muestra\n\n\nVolumen de datos\nMás grande debido al análisis de miles de células\nMenor, ya que es una única medición por muestra\n\n\nRuido técnico\nMás elevado (dropouts, captura limitada de ARN)\nMenor, ya que integra señales de muchas células\n\n\nAnálisis de heterogeneidad\nPosible (subpoblaciones y trayectorias celulares)\nNo posible (mezcla de señales celulares)\n\n\nCosto\nGeneralmente más alto\nGeneralmente más bajo\n\n\n\n\n\n1.4 Análisis de scRNA-seq con SingleCellExperiment (SCE)\nSingleCellExperiment es una clase de datos especializada en BioConductor para trabajar con datos de scRNA-seq:\n\nCarga de datos: Los datos se almacenan en un objeto SingleCellExperiment.\nPreprocesamiento: Incluye normalización, filtrado de células/géneros y corrección de efectos técnicos.\nAnálisis avanzado: Se pueden integrar con paquetes como scater (visualización) y scran (análisis de grupos celulares, clustering).\nIntegración: Compatible con otros flujos de trabajo en R y otros paquetes de BioConductor.\n\n\n1.4.1 Estructura\n\nassays: Almacena las matrices de datos, como las cuentas de expresión crudas (counts), normalizadas (logcounts), etc.\ncolData: Contiene metadatos relacionados con las células, como tipos celulares, calidad, etc.\nrowData: Contiene información sobre las características (genes), como IDs, descripciones, etc.\nreducedDims: Almacena datos de dimensionalidad reducida (PCA, UMAP, t-SNE).\nmetadata: Información adicional sobre el experimento.\naltExps (opcional): Almacena datos alternativos, como ARN de características específicas (ej., ADT para scRNA-seq multi-ómics).\n\n\n\n\n1.5 Ánalisis de scRNA-seq con Seurat\nSeurat es un paquete ampliamente utilizado para análisis de scRNA-seq:\n\nPipeline completo: Desde preprocesamiento hasta clustering, visualización y análisis diferencial.\nIntegración multi-ómics: Seurat permite analizar datos de scRNA-seq combinados con otros tipos de datos.\nVisualización: Herramientas como UMAP y t-SNE para reducir dimensiones y detectar patrones celulares.\n\n\n1.5.1 Estructura\n\nassays: Almacena los datos de expresión en distintos niveles de procesamiento (RNA, integraciones, etc.).\nmeta.data: Contiene metadatos de las células, como identificadores de clúster, etiquetas de tipo celular, etc.\nreductions: Almacena los resultados de métodos de reducción de dimensiones (PCA, UMAP, t-SNE).\ngraphs: Contiene gráficos derivados, como los usados para clustering basado en redes.\ncommands: Almacena el historial de los comandos utilizados para procesar el objeto.\ntools: Información adicional, como resultados de análisis diferenciales o integraciones.\n\n\n\n\n1.6 Comparación entre SCE y Seurat\n\n\n\n\n\n\n\n\nAspecto\nSingleCellExperiment (SCE)\nSeurat\n\n\n\n\nPlataforma principal\nR (BioConductor)\nR y Python\n\n\nEstructura de datos\nBasada en la clase SingleCellExperiment de BioConductor\nBasada en la clase SeuratObject\n\n\nFacilidad de uso\nMayor curva de aprendizaje debido a su modularidad\nMás intuitivo y directo, especialmente para principiantes\n\n\nPipeline integrado\nRequiere integración de múltiples paquetes (scater, scran)\nIncluye todo en un solo paquete: preprocesamiento, clustering, visualización\n\n\nFlexibilidad\nAltamente flexible y compatible con el ecosistema de BioConductor\nEnfocado en análisis estándar, con menos opciones para personalización profunda\n\n\nAnálisis de clustering\nHerramientas avanzadas con scran y otros paquetes\nIntegrado directamente con métodos optimizados\n\n\nVisualización\nHerramientas básicas con scater\nVisualización avanzada (UMAP, t-SNE, DimPlot)\n\n\nMulti-ómics\nLimitado a la integración mediante otros paquetes\nIntegración nativa de datos multi-ómics (por ejemplo, scRNA-seq + ATAC-seq)\n\n\nEscalabilidad\nMás eficiente en memoria para grandes conjuntos de datos\nRequiere más memoria, especialmente con conjuntos de datos muy grandes\n\n\nSoporte técnico\nComunidad fuerte dentro del ecosistema BioConductor\nAmplia comunidad de usuarios y documentación accesible\n\n\nInteroperabilidad\nCompatible con otros paquetes de BioConductor\nMenos interoperable fuera del ecosistema Seurat\n\n\nAnálisis diferencial\nDepende de herramientas externas como limma y edgeR\nIncluido como parte del flujo de trabajo\n\n\nCosto computacional\nMás eficiente para cálculos intensivos\nRequiere mayor capacidad computacional\n\n\nFacilidad de instalación\nPuede ser más complejo debido a dependencias de BioConductor\nFácil de instalar con CRAN o directamente desde GitHub\n\n\n\n\n\n1.7 Pipeline general para el análisis de datos de scRNA-seq\n\nEl pipeline general para el análisis de datos de scRNA-seq involucra una serie de pasos. Posterior al procesamiento de los reads, se procede a hacer un filtrado de las células en base a sus conteos y número de genes; se realiza una normalización de los datos y si es necesario una correción de batch (que es cuando se tiene en una misma matriz de datos el resultado de dos o más experimentos de secuenciación). Posterior a eso se seleccionan los genes altamente variables (HVG’s) y se realiza una reducción de dimensionalidad. Posterior a eso, se realiza una clusterización de las células. Una vez hecho esto se anotan las células para darles una identidad biológica en base a sus genes marcadores. Finalmente se pueden hacer otros experimentos como RNA velocity, Psuedotime y Gene dynamics.\nPara hacer el análisis se va a emplear el dataset de ejemplo de 10XGenomics PBMC4k el cual es de libre acceso. Vamos a descargar los datos.\n\n## Install remotes\nif (!requireNamespace(\"remotes\", quietly = TRUE)) {\n    install.packages(\"remotes\")\n}\n\n## Install BioConductor if not installed yet\nif (!requireNamespace(\"BiocManager\",quietly = TRUE)) {\n    remotes::install_cran(\"BiocManager\")\n}\n\nBiocManager::version()\n\n## Download the data\nbfc &lt;- BiocFileCache::BiocFileCache()\nraw.path &lt;- BiocFileCache::bfcrpath(bfc,file.path(\n    \"http://cf.10xgenomics.com/samples\",\n    \"cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz\"\n))\nuntar(raw.path,exdir = file.path(tempdir(),\"pbmc4k\"))\n\n## Define the path as a global variable\npbmc4k.path &lt;- file.path(tempdir(),\"pbmc4k/raw_gene_bc_matrices/GRCh38\")",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell RNA-seq</span>"
    ]
  },
  {
    "objectID": "chapters/Clase12_SingleCellRNAseq.html#bioconductor-singlecellexperiment",
    "href": "chapters/Clase12_SingleCellRNAseq.html#bioconductor-singlecellexperiment",
    "title": "Single-cell RNA-seq",
    "section": "2. Bioconductor SingleCellExperiment",
    "text": "2. Bioconductor SingleCellExperiment\n\n2.1 Load libraries\nCheck if libraries are installed\n\n## List of required libraries\nlibs &lt;- c(\"SingleCellExperiment\",\"scRNAseq\",\"AnnotationHub\",\"scater\",\"scran\",\"BiocFileCache\",\"DropletUtils\",\"Matrix\",\"PCAtools\",\"EnsDb.Hsapiens.v86\",\"clustree\",\"celldex\",\"SingleR\",\"AUCell\",\"GSEABase\",\"pheatmap\")\n\n# Check and install missing libraries\nfor (lib in libs) {\n    if (!requireNamespace(lib, quietly = TRUE)) {\n        message(paste(\"Installing\", lib))\n        \n        if (startsWith(lib, \"EnsDb.\") || lib %in% c(\"scRNAseq\", \"AnnotationHub\", \"scater\", \"scran\", \"BiocFileCache\", \"DropletUtils\", \"celldex\", \"SingleR\", \"AUCell\", \"GSEABase\")) {\n            BiocManager::install(lib,quiet = TRUE, ask = FALSE)\n        } else\n            install.packages(lib, quiet = TRUE)\n    } else\n        message(paste(lib, \"is already installed\"))\n}\n\nLoad libraries\n\n## Load libraries\nlibrary(scRNAseq)\nlibrary(AnnotationHub)\nlibrary(scater)\nlibrary(scran)\nlibrary(BiocFileCache)\nlibrary(DropletUtils)\nlibrary(Matrix)\nlibrary(PCAtools)\nlibrary(EnsDb.Hsapiens.v86)\nlibrary(clustree)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(AUCell)\nlibrary(GSEABase)\nlibrary(pheatmap)\n\n\n\n2.2 Create SCE object\n\n## As its an output of 10XGenomics we can read it with \n## the FxN read10xCounts from DropletUtils\nsce.pbmc &lt;- read10xCounts(pbmc4k.path,col.names = TRUE)\nsce.pbmc\n\n## class: SingleCellExperiment \n## dim: 33694 737280 \n## metadata(1): Samples\n## assays(1): counts\n## rownames(33694): ENSG00000243485 ENSG00000237613 ... ENSG00000277475\n##   ENSG00000268674\n## rowData names(2): ID Symbol\n## colnames(737280): AAACCTGAGAAACCAT-1 AAACCTGAGAAACCGC-1 ...\n##   TTTGTCATCTTTAGTC-1 TTTGTCATCTTTCCTC-1\n## colData names(2): Sample Barcode\n## reducedDimNames(0):\n## mainExpName: NULL\n## altExpNames(0):\n\n\n\n\n2.3 Add annotations\nSe tienen que unificar los features debido a que puede que haya duplicados dado que un mismo ENSEMBLID puede estar asignado a uno o más symbols (que son los nombre genéricos de los genes). Esta función es muy útil para extraer los metadatos de los genes. Literalmente es como si se pudiera descargar el archivo GTF.\n\n## Chromosome annotation\nrownames(sce.pbmc) &lt;- uniquifyFeatureNames(\n    rowData(sce.pbmc)$ID,rowData(sce.pbmc)$Symbol\n)\nchr.loc &lt;- AnnotationDbi::mapIds(EnsDb.Hsapiens.v86,\n                                 keys = rowData(sce.pbmc)$ID,\n                                 keytype = \"GENEID\",\n                                 column = \"SEQNAME\")\nhead(chr.loc,5)\n\n## ENSG00000243485 ENSG00000237613 ENSG00000186092 ENSG00000238009 ENSG00000239945 \n##             \"1\"             \"1\"             \"1\"             \"1\"             \"1\"\n\n\n\n\n2.4 Pre-filtering\nEl droplet detection se realiza para identificar cuáles de los millones de gotas generadas durante la preparación de la muestra contienen células reales (biológicas) y cuáles contienen únicamente ruido o artefactos técnicos. Este paso es crucial porque la tecnología de droplet-based scRNA-seq (como 10x Genomics Chromium) puede capturar tanto células individuales como gotas vacías o gotas con ARN ambiental.\nEn el análisis de droplet detection de scRNA-seq, se utiliza un enfoque basado en Monte Carlo para generar una distribución de p-valores que nos ayude a diferenciar entre las gotas con señales reales de las que solo contienen ruido. Aquí se aplica la idea de que, para cada gota, las distribuciones de las lecturas de ARN en una gota vacía deben seguir una distribución esperada si la gota no tiene una célula real.\nLa corrección de Benjamini-Hochberg (BH) se utiliza para controlar la tasa de falsos descubrimientos (FDR) cuando se realizan múltiples pruebas estadísticas. En este contexto, se aplica después de calcular los p-valores de Monte Carlo para las gotas.\nDado que estamos realizando muchas pruebas para cada gota (una por cada gota en el experimento), es importante corregir los p-valores para evitar obtener resultados falsos positivos debido a múltiples comparaciones.\nEste enfoque permite mejorar la precisión del análisis de scRNA-seq al reducir el impacto del ruido técnico y asegurarse de que los resultados reflejan datos biológicos reales.\nLa semilla es esencial para fines de reproducibilidad.\nTotal UMI count\n\n\n\n\n\n\n\n\n\n\n## Droplet detection\nset.seed(100)\ne.out &lt;- emptyDrops(counts(sce.pbmc))\n\n## See ?emptyDrops for an explanation of why there are NA values.\nsummary(e.out$FDR &lt;= 0.001)\n\n##    Mode   FALSE    TRUE    NA's \n## logical     989    4300  731991\n\nsce.pbmc &lt;- sce.pbmc[,which(e.out$FDR &lt;= 0.001)]\nsce.pbmc\n\n## class: SingleCellExperiment \n## dim: 33694 4300 \n## metadata(1): Samples\n## assays(1): counts\n## rownames(33694): RP11-34P13.3 FAM138A ... AC213203.1 FAM231B\n## rowData names(2): ID Symbol\n## colnames(4300): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ...\n##   TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1\n## colData names(2): Sample Barcode\n## reducedDimNames(0):\n## mainExpName: NULL\n## altExpNames(0):\n\n## Limited: whether the or not the computed p-value for a particular barcode is bounded by the number of iterations.\ntable(Sig=e.out$FDR &lt;= 0.001, Limited=e.out$Limited)\n\n##        Limited\n## Sig     FALSE TRUE\n##   FALSE   989    0\n##   TRUE   1728 2572\n\n\n\n\n2.5 Quality Control (QC)\nAquí se calculas las métricas de control de calidad para las células.\n\nperCellQCMetrics(): Esta función calcula diversas métricas de calidad por célula en el objeto SingleCellExperiment (sce.pbmc). Las métricas más comunes incluyen el número de genes detectados por célula, el total de lecturas, el porcentaje de ARN mitocondrial, etc.\nsubsets = list(MT = which(chr.loc == \"MT\")): Aquí, se está especificando que se debe calcular el porcentaje de lecturas que provienen de genes mitocondriales.\n\nwhich(chr.loc == \"MT\"): Esta parte identifica los índices de las características (genes) que corresponden al cromosoma mitocondrial. Esto permite calcular qué proporción del ARN proviene de genes mitocondriales.\nEl resultado es un objeto stats que contiene las métricas de calidad para cada célula, incluyendo el porcentaje de ARN mitocondrial.\n\nisOutlier(): Esta función detecta células que tienen valores atípicos para la métrica especificada (en este caso, el porcentaje de ARN mitocondrial). Se utiliza aquí para identificar las células con un porcentaje de ARN mitocondrial inusualmente alto.\n\nstats$subsets_MT_percent: Esto extrae el porcentaje de ARN mitocondrial para cada célula del objeto stats.\ntype = \"higher\": Este parámetro indica que se buscan valores atípicos altos. En este caso, se está buscando identificar células que tienen un alto porcentaje de ARN mitocondrial, lo que puede ser indicativo de estrés celular o de células que no están viables.\n\n\nAntes se tiene que checar cuál es el estado de las células\n\n## Quality Control\nstats &lt;- perCellQCMetrics(sce.pbmc,\n                          subsets = list(MT = which(chr.loc == \"MT\")))\nhigh.mito &lt;- isOutlier(stats$subsets_MT_percent,type = \"higher\")\nsce.pbmc &lt;- sce.pbmc[,!high.mito]\nsce.pbmc\n\n## class: SingleCellExperiment \n## dim: 33694 3985 \n## metadata(1): Samples\n## assays(1): counts\n## rownames(33694): RP11-34P13.3 FAM138A ... AC213203.1 FAM231B\n## rowData names(2): ID Symbol\n## colnames(3985): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ...\n##   TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1\n## colData names(2): Sample Barcode\n## reducedDimNames(0):\n## mainExpName: NULL\n## altExpNames(0):\n\n## SUmmary of high mitocondrial trnascripts\nsummary(high.mito)\n\n##    Mode   FALSE    TRUE \n## logical    3985     315\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.6 Normalization\nLa normalización es crucial en los datos de scRNA-seq porque:\n\nLas células pueden tener diferentes números de lecturas debido a diversos factores técnicos, como la eficiencia de captura de ARN o la cantidad de ARN disponible en cada célula.\nSin normalización, las células con más lecturas tendrán una ventaja artificial, lo que podría sesgar el análisis.\nAl normalizar y aplicar la transformación logarítmica, se asegura que las diferencias observadas reflejan más las diferencias biológicas entre las células que las diferencias técnicas.\n\n\n\nquickCluster(): Esta función realiza un clustering rápido de las células basándose en sus perfiles de expresión génica. El propósito de este paso es agrupar las células en clusters o grupos que tengan perfiles de expresión similares. Estos clusters se usarán posteriormente para calcular los factores de normalización, que ayudan a corregir las diferencias técnicas entre células.\nclusters: Este objeto almacena los clusters identificados. La función utiliza un enfoque jerárquico para agrupar las células de forma que las células dentro de un mismo grupo sean lo más similares posibles entre sí, mientras que las células de diferentes grupos serán lo más distintas posible.\ncomputeSumFactors(): Esta función calcula los factores de normalización para cada célula. Los factores de normalización se utilizan para corregir las diferencias en la cantidad de ARN total capturado entre las células. Esto es importante porque, aunque las células tengan diferentes cantidades de ARN, estas diferencias no siempre reflejan diferencias biológicas.\n\nEl argumento cluster = clusters indica que el cálculo de los factores de normalización se debe hacer dentro de los grupos (clusters) identificados previamente. Esto permite una normalización más precisa al tomar en cuenta las variaciones técnicas dentro de cada cluster, en lugar de normalizar todas las células de manera global.\ncomputeSumFactors() usa el método de sumFactors, que es una técnica popular en análisis de datos de single-cell RNA-seq para ajustar las diferencias de secuenciación entre células, utilizando los clusters de células con expresión similar.\n\nlogNormCounts(): Esta función aplica una transformación logarítmica a los conteos normalizados de cada célula. Después de que los factores de normalización han sido calculados y aplicados a los datos, se toma el logaritmo de los conteos normalizados. Esto se hace por varias razones:\n\nReducción de la variabilidad: Los conteos de ARN en células individuales pueden variar en varios órdenes de magnitud. Aplicar el logaritmo reduce esta variabilidad y hace que las diferencias entre los genes sean más manejables.\nDistribución más normal: Los datos de RNA-seq suelen tener una distribución sesgada. El logaritmo de los conteos normalizados ayuda a transformar la distribución a una forma más cercana a una distribución normal, lo cual es preferible para muchos métodos estadísticos y de análisis.\n\n\n\n## Normalization\nset.seed(1000)\nclusters &lt;- quickCluster(sce.pbmc)\nsce.pbmc &lt;- computeSumFactors(sce.pbmc,\n                              cluster = clusters)\nsce.pbmc &lt;- logNormCounts(sce.pbmc)\nsce.pbmc\n\n## class: SingleCellExperiment \n## dim: 33694 3985 \n## metadata(1): Samples\n## assays(2): counts logcounts\n## rownames(33694): RP11-34P13.3 FAM138A ... AC213203.1 FAM231B\n## rowData names(2): ID Symbol\n## colnames(3985): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ...\n##   TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1\n## colData names(3): Sample Barcode sizeFactor\n## reducedDimNames(0):\n## mainExpName: NULL\n## altExpNames(0):\n\n\n\n\n\n2.7 Highly Variable Genes (HVG’s)\nEste proceso es crucial para reducir la dimensionalidad de los datos, ya que los análisis posteriores (como PCA, clustering, o análisis diferencial) se realizarán solo sobre estos genes seleccionados. Los HVGs se consideran informativos porque reflejan la diversidad biológica entre las células y no tanto el ruido técnico.\n\ndec.pbmc &lt;- modelGeneVarByPoisson(sce.pbmc):\n\nAquí, se ajusta un modelo basado en el supuesto de una distribución de Poisson para modelar la varianza génica.\nmodelGeneVarByPoisson utiliza la media esperada y asume que la varianza sigue la distribución de Poisson (donde la varianza es igual a la media). Si se observa varianza adicional, esto indica que hay factores biológicos (y no solo ruido técnico) contribuyendo a esa variabilidad.\nEl objeto resultante, dec.pbmc, es un marco de datos que contiene estadísticas como la media, la varianza observada y la varianza esperada para cada gen, además de la “varianza residual” (exceso de varianza).\n\nhvg.pbmc &lt;- getTopHVGs(dec.pbmc, prop = 0.1):\n\ngetTopHVGs selecciona los genes con mayor varianza residual. En este caso, se selecciona el 10% de los genes más variables (proporción especificada con prop = 0.1).\nEl resultado, hvg.pbmc, es un vector con los nombres de los genes considerados como HVGs.\n\n\nExisten otras alternativas para calcular la varianza donde se asumen otro tipo de distribuciones como una binomial negativa.\n\nmodelGeneVar: En lugar de asumir una distribución de Poisson, esta función estima la varianza génica usando una distribución basada en la media esperada pero permitiendo una dispersión superior, como en una distribución negativa binomial. Esto es más realista para datos de scRNA-seq, donde la dispersión suele ser mayor que la que predice una Poisson pura.\n\n\n## Variable Genes\nset.seed(1001)\ndec.pbmc &lt;- modelGeneVar(sce.pbmc)\nhvg.pbmc &lt;- getTopHVGs(dec.pbmc,prop = 0.1)\nhead(hvg.pbmc,5)\n\n## [1] \"LYZ\"     \"S100A9\"  \"S100A8\"  \"HLA-DRA\" \"CD74\"\n\n\n\n\n2.8 Dimensionality Reduction\n\nPCA (Análisis de Componentes Principales):\n\nProyecta los datos en componentes ortogonales que explican la mayor parte de la varianza.\nEs útil para filtrar ruido y trabajar con los componentes principales más informativos.\nFrecuentemente es el primer paso en muchos análisis (por ejemplo, clustering y visualización).\nLimitación: Lineal, no siempre captura relaciones no lineales complejas.\n\nt-SNE (t-distributed Stochastic Neighbor Embedding):\n\nTécnica no lineal para proyectar datos en 2 o 3 dimensiones.\nSe utiliza principalmente para la visualización, resaltando la proximidad de células en un espacio reducido.\nNo es ideal para análisis cuantitativos o clustering directo, ya que la distancia en el espacio t-SNE no siempre refleja relaciones cuantitativas precisas.\n\nUMAP (Uniform Manifold Approximation and Projection):\n\nSimilar a t-SNE, pero conserva mejor las relaciones globales y locales en los datos.\nSe utiliza ampliamente para visualización y también como entrada para clustering.\nEs más rápido y escalable que t-SNE.\n\n\n\n## Dimensionality reduction\nset.seed(10000)\nsce.pbmc &lt;- denoisePCA(sce.pbmc,\n                       subset.row = hvg.pbmc,\n                       technical = dec.pbmc\n                       )\nset.seed(100000)\nsce.pbmc &lt;- runTSNE(sce.pbmc,dimred = \"PCA\")\n\nset.seed(100000)\nsce.pbmc &lt;- runUMAP(sce.pbmc,dimred = \"PCA\")\n\n\n\n2.9 Clustering\nSe necesita agrupar las células para identificar a las poblaciones celulares dentro del dataset.\n\nbuildSNNGraph: Esta función construye un grafo de vecinos más cercanos (SNN, por sus siglas en inglés) basado en la similitud entre las células, utilizando una matriz de distancias o similitudes. El grafo resultante captura las relaciones entre las células según su proximidad en un espacio de características (en este caso, el espacio de reducción de dimensionalidad).\n\n\n\nsce.pbmc: Es el objeto SingleCellExperiment que contiene los datos de expresión génica de las células.\nk = 10: Es el número de vecinos más cercanos que se consideran al construir el grafo. Es decir, para cada célula, se encuentran las 10 células más similares basadas en las características (en este caso, las componentes principales de la PCA).\nuse.dimred = \"PCA\": Esto indica que el grafo se construirá en base a las componentes principales (PCA) previamente calculadas, no sobre los datos originales de expresión génica. Usar un espacio reducido de dimensionalidad como PCA ayuda a reducir el ruido técnico y mejora la eficiencia computacional.\nigraph::cluster_walktrap(g): Utiliza el algoritmo Walktrap para realizar el clustering basado en el grafo de vecinos más cercanos.\n\nWalktrap es un algoritmo de clustering de grafos que busca identificar grupos de nodos (en este caso, células) que están fuertemente conectados entre sí. La idea es realizar una caminata aleatoria en el grafo y ver qué nodos (células) se visitan juntos con mayor frecuencia, lo que indica que son parte del mismo grupo.\n\n\n\n\n$membership: El resultado del algoritmo es un objeto que indica a qué grupo (o clúster) pertenece cada célula. Este vector de pertenencia se guarda en clust.\n\n\n## Clustering\ng &lt;- buildSNNGraph(sce.pbmc,\n                   k = 10,\n                   use.dimred = \"PCA\")\nclust &lt;- igraph::cluster_walktrap(g)$membership\nsce.pbmc$cluster &lt;- factor(clust)\n\nPlotting\n\n## PCA\nplotReducedDim(sce.pbmc,\n               dimred = \"PCA\",\n               colour_by=\"cluster\") +\n    ggtitle(\"Default PCA\")\n\n\n\n\n\n\n\n## UMAP\nplotReducedDim(sce.pbmc,\n               dimred = \"UMAP\",\n               colour_by=\"cluster\") +\n    ggtitle(\"Default UMAP\")\n\n\n\n\n\n\n\n## t-SNE\nplotReducedDim(sce.pbmc,\n               dimred = \"TSNE\",\n               colour_by=\"cluster\") +\n    ggtitle(\"Default t-SNE\")\n\n\n\n\n\n\n\n\n\n\n2.10 Cell type Annotation\nLa anotación de poblaciones celulares en datos de scRNA-seq (secuenciación de ARN de células individuales) es fundamental para identificar y caracterizar subpoblaciones celulares dentro de una muestra. Este proceso permite asignar etiquetas específicas a las células según sus perfiles de expresión génica, facilitando la comprensión de la heterogeneidad celular y la identificación de tipos celulares o estados funcionales particulares.\nImportancia de la anotación de poblaciones celulares en scRNA-seq:\n\nIdentificación de tipos y estados celulares: La anotación precisa permite reconocer diferentes tipos celulares y sus estados funcionales, lo que es esencial para comprender procesos biológicos complejos y enfermedades.\nComprensión de la heterogeneidad celular: Ayuda a desentrañar la variabilidad entre células, revelando subpoblaciones que podrían ser relevantes en contextos fisiológicos o patológicos.\nInterpretación de datos de expresión génica: Facilita la interpretación de patrones de expresión génica al asociar perfiles específicos con tipos celulares conocidos.\nIntegración de datos de diferentes fuentes: La anotación estandarizada permite combinar datos de diferentes experimentos o plataformas, enriqueciendo el análisis global.\n\nMétodos para la anotación de células utilizando correlaciones de Spearman y genes marcadores:\nUna estrategia efectiva para la anotación de células implica el uso de correlaciones de rangos de Spearman y genes marcadores específicos. Este enfoque se puede desglosar en los siguientes pasos:\n\nAsignación inicial de etiquetas basada en correlaciones de Spearman:\n\nSe calculan las correlaciones de Spearman entre los perfiles de expresión génica de las células en el conjunto de datos y las muestras de referencia de tipos celulares conocidos.\nLas células se etiquetan según las muestras de referencia con las correlaciones de rangos más altas, asignándoles el tipo celular correspondiente.\n\nReducción de ruido mediante identificación de genes marcadores:\n\nPara minimizar la influencia de genes que podrían introducir ruido, se identifican genes marcadores específicos entre pares de etiquetas en las muestras de referencia.\nSe recalculan las correlaciones utilizando únicamente estos genes marcadores, enfocándose en las características más distintivas de cada tipo celular.\n\nAfinamiento de la anotación mediante correlaciones adicionales:\n\nSe realiza un ajuste fino repitiendo las correlaciones, pero esta vez utilizando solo los genes marcadores de las etiquetas con el mejor puntaje de correlación.\nEste proceso ayuda a resolver ambigüedades entre etiquetas similares al eliminar el ruido de genes irrelevantes para otras etiquetas, mejorando la precisión de la anotación.\n\n\n\n## Using the reference\nref &lt;- celldex::BlueprintEncodeData()\n\n## Use built-in references\npred &lt;- SingleR(test = sce.pbmc,\n                ref = ref,\n                labels = ref$label.main)\n\n## Plot the per-cell and label scores\nplotScoreHeatmap(pred)\n\n\n\n\n\n\n\n## Label pruning\nsum(is.na(pred$pruned.labels))\n\n## [1] 75\n\nplotScoreHeatmap(pred,\n                 show.pruned = TRUE)\n\n\n\n\n\n\n\n## Plot distribution\nplotScoreDistribution(pred)\n\n\n\n\n\n\n\n\n\n\n2.10.1 Identifying genes driving annotation\n\nsce.pbmc$labels &lt;- pred$labels\nall.markers &lt;- metadata(pred)$de.genes\nlab &lt;- \"B-cells\"\n\n## Get the top 10 marker genes for B-cells\ntop.markers &lt;- Reduce(union,sapply(all.markers[[lab]], head,10))\n\nplotHeatmap(sce.pbmc,\n            order_columns_by = \"labels\",\n            features = top.markers,\n            center = TRUE,\n            zlim = c(-3,3),\n            main = lab)\n\n\n\n\n\n\n\n\n\n\n2.10.2 Comparing labels to clusters\n\n## Order the heatmap by cluster\nplotScoreHeatmap(pred,\n                 clusters = sce.pbmc$cluster,\n                 order.by.cluster = TRUE)\n\n\n\n\n\n\n\n## Compare labels to clusters\ntab &lt;- table(Assigned = pred$pruned.labels,\n             Cluster = sce.pbmc$cluster)\ntab\n\n##               Cluster\n## Assigned         1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n##   B-cells        0   1   0 418   0 112   0   0   0   0   0   0   0   0  13\n##   CD4+ T-cells   2 240   0   0 523   0   0   0   0   0   0   1   0   0   0\n##   CD8+ T-cells   6 356 401   0 495   8   1   0   0   0   0   0   0   0   0\n##   DC             0   0   0   0   0   0   0   0   0   0   0   0   0   0   1\n##   Eosinophils    0   0   0   0   0   0   1   0   0   0   0   0   0   0   0\n##   Erythrocytes   0   1   0   0   0   0   5   0   0   0   0   0   0   0   0\n##   HSC            0   0   0   0   0   8   0   0   0   0   0   0   0   0   6\n##   Monocytes      0   0   0   0   0   0   1 132 298 142 336  38  90  16  16\n##   NK cells     164   1  75   0   0   2   0   0   0   0   0   0   0   0   0\n\n## Add labels to TSNE\nplotTSNE(sce.pbmc,\n         colour_by = \"labels\",\n         text_by = \"labels\")\n\n\n\n\n\n\n\n## Now color by cluster\nplotTSNE(sce.pbmc,\n         colour_by = \"cluster\",\n         text_by = \"labels\")\n\n\n\n\n\n\n\n\nAdicionalmente se recomienda realizar un Análisis de Expresión Diferencial (DEA) o de Abundancia Diferencial ya que nos permite obtener mayor resolución biológica que experimentos convencionales de bulk RNA-seq, sobretodo si se pueden asociar cambios de expresión a nivel de poblaciones celulares.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell RNA-seq</span>"
    ]
  },
  {
    "objectID": "chapters/Clase12_SingleCellRNAseq.html#seurat",
    "href": "chapters/Clase12_SingleCellRNAseq.html#seurat",
    "title": "Single-cell RNA-seq",
    "section": "3. Seurat",
    "text": "3. Seurat\nLos pasos aquí son mucho más simples.\n\n3.1 Load libraries\nInstall libraries\n\n## Install the needed libs\nlibs &lt;- c(\"patchwork\",\"batchelor\",\"Seurat\")\nfor (lib in libs) {\n    if (!requireNamespace(lib, quietly = TRUE)) {\n        BiocManager::install(lib,quiet = TRUE, ask = FALSE)\n    }\n}\n\n## Load libraries\nlibrary(BiocFileCache)\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(patchwork)\n\n\n\n3.2 Create Seurat object\n\n## Load the PBMC dataset\npbmc.data &lt;- Read10X(data.dir = pbmc4k.path)\n\n## Initialize the Seurat object with the raw (non-normalized data).\npbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = \"pbmc4k\", min.cells = 3, min.features = 200)\n\ndim(pbmc)\n\n## [1] 16746  4782\n\nhead(rownames(pbmc))\n\n## [1] \"RP11-34P13.7\"  \"FO538757.2\"    \"AP006222.2\"    \"RP4-669L17.10\"\n## [5] \"RP11-206L10.9\" \"LINC00115\"\n\nhead(colnames(pbmc))\n\n## [1] \"AAACCTGAGAAGGCCT-1\" \"AAACCTGAGACAGACC-1\" \"AAACCTGAGATAGTCA-1\"\n## [4] \"AAACCTGAGCGCCTCA-1\" \"AAACCTGAGGCATGGT-1\" \"AAACCTGCAAGGTTCT-1\"\n\n\nExplore Seurat object\n\nnames(pbmc)\n\n## [1] \"RNA\"\n\n## Check the only assay\npbmc[[\"RNA\"]]\n\n## Assay (v5) data with 16746 features for 4782 cells\n## First 10 features:\n##  RP11-34P13.7, FO538757.2, AP006222.2, RP4-669L17.10, RP11-206L10.9,\n## LINC00115, FAM41C, SAMD11, NOC2L, KLHL17 \n## Layers:\n##  counts\n\n## Get some assay data\nGetAssayData(object = pbmc, layer = \"counts\")[1:3, 1:3]\n\n## 3 x 3 sparse Matrix of class \"dgCMatrix\"\n##              AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 AAACCTGAGATAGTCA-1\n## RP11-34P13.7                  .                  .                  .\n## FO538757.2                    .                  .                  .\n## AP006222.2                    .                  .                  .\n\n## Access metadata\nhead(pbmc@meta.data)\n\n\n  \n\n\n## We can also acces like this\nhead(pbmc[[c(\"nCount_RNA\", \"nFeature_RNA\")]])\n\n\n  \n\n\n## Passing `drop = TRUE` will turn the meta data into a names vector\n## with each entry being named for the cell it corresponds to\nhead(pbmc[[\"nCount_RNA\", drop = TRUE]])\n\n## AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 AAACCTGAGATAGTCA-1 AAACCTGAGCGCCTCA-1 \n##               1738               3240               1683               2318 \n## AAACCTGAGGCATGGT-1 AAACCTGCAAGGTTCT-1 \n##               2983               4181\n\n\n\n\n3.3 Quality Control (QC)\n\n## Add mitochondrial stats\npbmc[[\"percent.mt\"]] &lt;- PercentageFeatureSet(pbmc, pattern = \"^MT-\")\n\n## Quality control metrics\nVlnPlot(pbmc, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), ncol = 3)\n\n\n\n\n\n\n\nplot1 &lt;- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\nplot2 &lt;- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\nplot1 + plot2\n\n\n\n\n\n\n\n## Filter cells\npbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 & nFeature_RNA &lt; 2500 & percent.mt &lt; 5)\n\nhead(pbmc@meta.data, 5)\n\n\n  \n\n\n\n\n\n3.4 Normalization\n\npbmc &lt;- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\n\n\n\n3.5 Highly Variable Genes (HVG’s)\n\n## Gene detection\npbmc &lt;- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n\n## Identify the 10 most highly variable genes\ntop10 &lt;- head(VariableFeatures(pbmc), 10)\ntop10\n\n\n# plot variable features with and without labels\nplot1 &lt;- VariableFeaturePlot(pbmc)\n\n## When using repel, set xnudge and ynudge to 0 for optimal results\nplot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE)\n\nplot1 + plot2\n\n\n\n\n\n\n\n\n\n\n3.6 Data Scaling\n\nall.genes &lt;- rownames(pbmc)\npbmc &lt;- ScaleData(pbmc, features = all.genes)\n\n\n\n3.7 Lineal Dimensionality Reduction\n\npbmc &lt;- RunPCA(pbmc, features = VariableFeatures(object = pbmc))\n\nPlot\n\nprint(pbmc[[\"pca\"]], dims = 1:5, nfeatures = 5)\n\n## PC_ 1 \n## Positive:  TRAC, LTB, CD3D, MALAT1, IL32 \n## Negative:  CSTA, CST3, MNDA, LYZ, FCN1 \n## PC_ 2 \n## Positive:  CD79A, MS4A1, IGHM, CD79B, IGHD \n## Negative:  HCST, IL32, CTSW, NKG7, GZMA \n## PC_ 3 \n## Positive:  RPS12, LEF1, EEF1A1, RPLP1, RPS18 \n## Negative:  NKG7, GZMB, CST7, PRF1, KLRD1 \n## PC_ 4 \n## Positive:  MALAT1, RPLP1, EEF1A1, RPS18, RPS12 \n## Negative:  PPBP, TUBB1, SDPR, PF4, ACRBP \n## PC_ 5 \n## Positive:  IGHD, MS4A1, CD79A, CD79B, LINC00926 \n## Negative:  LILRA4, LRRC26, CLEC4C, SERPINF1, TPM2\n\nVizDimLoadings(pbmc, dims = 1:2, reduction = \"pca\")\n\n\n\n\n\n\n\nDimPlot(pbmc, reduction = \"pca\")\n\n\n\n\n\n\n\nDimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)\n\n\n\n\n\n\n\nDimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)\n\n\n\n\n\n\n\n\n\n3.6.1 Choose Principal Components\n\npbmc &lt;- JackStraw(pbmc, num.replicate = 100)\npbmc &lt;- ScoreJackStraw(pbmc, dims = 1:20)\n\nPlot\n\nJackStrawPlot(pbmc, dims = 1:15)\n\n\n\n\n\n\n\nElbowPlot(pbmc)\n\n\n\n\n\n\n\n\n\n\n\n3.7 Clustering\n\npbmc &lt;- FindNeighbors(pbmc, dims = 1:10)\n## Computing nearest neighbor graph\n## Computing SNN\npbmc &lt;- FindClusters(pbmc, resolution = 0.5)\n\n\n\n3.8 Non-lineal DImensionality Reduction\n\npbmc &lt;- RunUMAP(pbmc, dims = 1:10)\npbmc &lt;- RunTSNE(pbmc,dims = 1:10)\n\nPlot\n\nDimPlot(pbmc, reduction = \"umap\")\n\n\n\n\n\n\n\nDimPlot(pbmc, reduction = \"tsne\")\n\n\n\n\n\n\n\n\n\n\n3.8 Cluster Marker Genes\n\n## find markers for every cluster compared to all remaining cells, report only the positive ones\npbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)\n\npbmc.markers %&gt;%\n    group_by(cluster) %&gt;%\n    top_n(n = 2, wt = avg_log2FC)\ncluster0.markers &lt;- FindMarkers(pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = \"roc\", only.pos = TRUE)\n\nPlot\n\nVlnPlot(pbmc, features = c(\"MS4A1\", \"CD79A\"))\n\n\n\n\n\n\n\nFeaturePlot(pbmc, features = c(\n    \"MS4A1\", \"GNLY\", \"CD3E\", \"CD14\", \"FCER1A\", \"FCGR3A\", \"LYZ\", \"PPBP\",\n    \"CD8A\"\n))\n\n\n\n\n\n\n\npbmc.markers %&gt;%\n    group_by(cluster) %&gt;%\n    top_n(n = 10, wt = avg_log2FC) -&gt; top10\nDoHeatmap(pbmc, features = top10$gene) + NoLegend()\n\n\n\n\n\n\n\n\n\n\n3.8 Cell type Annotation\nSe puede integrar con SingleR pero no es tan fácil.\n\nDimPlot(pbmc, reduction = \"tsne\", label = TRUE, pt.size = 0.5) + NoLegend()",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell RNA-seq</span>"
    ]
  },
  {
    "objectID": "chapters/Clase12_SingleCellRNAseq.html#reproducibilidad",
    "href": "chapters/Clase12_SingleCellRNAseq.html#reproducibilidad",
    "title": "Single-cell RNA-seq",
    "section": "Reproducibilidad",
    "text": "Reproducibilidad\n\n\n## ─ Session info ───────────────────────────────────────────────────────────────\n##  setting  value\n##  version  R version 4.4.2 (2024-10-31 ucrt)\n##  os       Windows 11 x64 (build 26100)\n##  system   x86_64, mingw32\n##  ui       RTerm\n##  language (EN)\n##  collate  English_United States.utf8\n##  ctype    English_United States.utf8\n##  tz       America/Mexico_City\n##  date     2025-01-21\n##  pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n## \n## ─ Packages ───────────────────────────────────────────────────────────────────\n##  ! package              * version   date (UTC) lib source\n##    abind                  1.4-8     2024-09-12 [1] CRAN (R 4.4.1)\n##    alabaster.base         1.6.1     2024-11-10 [1] Bioconductor 3.20 (R 4.4.1)\n##    alabaster.matrix       1.6.1     2024-11-20 [1] Bioconductor 3.20 (R 4.4.2)\n##    alabaster.ranges       1.6.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    alabaster.sce          1.6.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    alabaster.schemas      1.6.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    alabaster.se           1.6.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    annotate             * 1.84.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    AnnotationDbi        * 1.68.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    AnnotationFilter     * 1.30.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    AnnotationHub        * 3.14.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    AUCell               * 1.28.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    batchelor              1.22.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    beachmat               2.22.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    beeswarm               0.4.0     2021-06-01 [1] CRAN (R 4.4.0)\n##    Biobase              * 2.66.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    BiocFileCache        * 2.14.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    BiocGenerics         * 0.52.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    BiocIO                 1.16.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    BiocManager            1.30.25   2024-08-28 [1] CRAN (R 4.4.2)\n##    BiocNeighbors          2.0.1     2024-11-28 [1] Bioconductor 3.20 (R 4.4.2)\n##    BiocParallel           1.40.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    BiocSingular           1.22.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    BiocVersion            3.20.0    2024-10-21 [1] Bioconductor 3.20 (R 4.4.1)\n##    Biostrings             2.74.1    2024-12-16 [1] Bioconductor 3.20 (R 4.4.2)\n##    bit                    4.5.0.1   2024-12-03 [1] CRAN (R 4.4.2)\n##    bit64                  4.5.2     2024-09-22 [1] CRAN (R 4.4.2)\n##    bitops                 1.0-9     2024-10-03 [1] CRAN (R 4.4.1)\n##    blob                   1.2.4     2023-03-17 [1] CRAN (R 4.4.2)\n##    bluster                1.16.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    cachem                 1.1.0     2024-05-16 [1] CRAN (R 4.4.2)\n##    celldex              * 1.16.0    2024-10-31 [1] Bioconductor 3.20 (R 4.4.2)\n##    cli                    3.6.3     2024-06-21 [1] CRAN (R 4.4.2)\n##    cluster                2.1.6     2023-12-01 [2] CRAN (R 4.4.2)\n##    clustree             * 0.5.1     2023-11-05 [1] CRAN (R 4.4.2)\n##    codetools              0.2-20    2024-03-31 [2] CRAN (R 4.4.2)\n##    colorspace             2.1-1     2024-07-26 [1] CRAN (R 4.4.2)\n##    cowplot                1.1.3     2024-01-22 [1] CRAN (R 4.4.2)\n##    crayon                 1.5.3     2024-06-20 [1] CRAN (R 4.4.2)\n##    curl                   6.0.1     2024-11-14 [1] CRAN (R 4.4.2)\n##    data.table             1.16.4    2024-12-06 [1] CRAN (R 4.4.2)\n##    DBI                    1.2.3     2024-06-02 [1] CRAN (R 4.4.2)\n##    dbplyr               * 2.5.0     2024-03-19 [1] CRAN (R 4.4.2)\n##    DelayedArray           0.32.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    DelayedMatrixStats     1.28.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    deldir                 2.0-4     2024-02-28 [1] CRAN (R 4.4.0)\n##    digest                 0.6.37    2024-08-19 [1] CRAN (R 4.4.2)\n##    dotCall64              1.2       2024-10-04 [1] CRAN (R 4.4.2)\n##    dplyr                * 1.1.4     2023-11-17 [1] CRAN (R 4.4.2)\n##    dqrng                  0.4.1     2024-05-28 [1] CRAN (R 4.4.2)\n##    DropletUtils         * 1.26.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    edgeR                  4.4.1     2024-12-02 [1] Bioconductor 3.20 (R 4.4.2)\n##    EnsDb.Hsapiens.v86   * 2.99.0    2024-12-22 [1] Bioconductor\n##    ensembldb            * 2.30.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    evaluate               1.0.1     2024-10-10 [1] CRAN (R 4.4.2)\n##    ExperimentHub          2.14.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    farver                 2.1.2     2024-05-13 [1] CRAN (R 4.4.2)\n##    fastDummies            1.7.4     2024-08-16 [1] CRAN (R 4.4.2)\n##    fastmap                1.2.0     2024-05-15 [1] CRAN (R 4.4.2)\n##    filelock               1.0.3     2023-12-11 [1] CRAN (R 4.4.2)\n##    fitdistrplus           1.2-1     2024-07-12 [1] CRAN (R 4.4.2)\n##    FNN                    1.1.4.1   2024-09-22 [1] CRAN (R 4.4.2)\n##    future                 1.34.0    2024-07-29 [1] CRAN (R 4.4.2)\n##    future.apply           1.11.3    2024-10-27 [1] CRAN (R 4.4.2)\n##    generics               0.1.3     2022-07-05 [1] CRAN (R 4.4.2)\n##    GenomeInfoDb         * 1.42.1    2024-11-28 [1] Bioconductor 3.20 (R 4.4.2)\n##    GenomeInfoDbData       1.2.13    2024-12-22 [1] Bioconductor\n##    GenomicAlignments      1.42.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    GenomicFeatures      * 1.58.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    GenomicRanges        * 1.58.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    ggbeeswarm             0.7.2     2023-04-29 [1] CRAN (R 4.4.2)\n##    ggforce                0.4.2     2024-02-19 [1] CRAN (R 4.4.2)\n##    ggplot2              * 3.5.1     2024-04-23 [1] CRAN (R 4.4.2)\n##    ggraph               * 2.2.1     2024-03-07 [1] CRAN (R 4.4.2)\n##    ggrastr                1.0.2     2023-06-01 [1] CRAN (R 4.4.2)\n##    ggrepel              * 0.9.6     2024-09-07 [1] CRAN (R 4.4.2)\n##    ggridges               0.5.6     2024-01-23 [1] CRAN (R 4.4.2)\n##    globals                0.16.3    2024-03-08 [1] CRAN (R 4.4.0)\n##    glue                   1.8.0     2024-09-30 [1] CRAN (R 4.4.2)\n##    goftest                1.2-3     2021-10-07 [1] CRAN (R 4.4.0)\n##    graph                * 1.84.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    graphlayouts           1.2.1     2024-11-18 [1] CRAN (R 4.4.2)\n##    gridExtra              2.3       2017-09-09 [1] CRAN (R 4.4.2)\n##    GSEABase             * 1.68.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    gtable                 0.3.6     2024-10-25 [1] CRAN (R 4.4.2)\n##    gypsum                 1.2.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    HDF5Array              1.34.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    htmltools              0.5.8.1   2024-04-04 [1] CRAN (R 4.4.2)\n##    htmlwidgets            1.6.4     2023-12-06 [1] CRAN (R 4.4.2)\n##    httpuv                 1.6.15    2024-03-26 [1] CRAN (R 4.4.2)\n##    httr                   1.4.7     2023-08-15 [1] CRAN (R 4.4.2)\n##    httr2                  1.0.7     2024-11-26 [1] CRAN (R 4.4.2)\n##    ica                    1.0-3     2022-07-08 [1] CRAN (R 4.4.0)\n##    igraph                 2.1.2     2024-12-07 [1] CRAN (R 4.4.2)\n##    IRanges              * 2.40.1    2024-12-05 [1] Bioconductor 3.20 (R 4.4.2)\n##    irlba                  2.3.5.1   2022-10-03 [1] CRAN (R 4.4.2)\n##    jsonlite               1.8.9     2024-09-20 [1] CRAN (R 4.4.2)\n##    KEGGREST               1.46.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    KernSmooth             2.23-24   2024-05-17 [2] CRAN (R 4.4.2)\n##    knitr                  1.49      2024-11-08 [1] CRAN (R 4.4.2)\n##    labeling               0.4.3     2023-08-29 [1] CRAN (R 4.4.0)\n##    later                  1.4.1     2024-11-27 [1] CRAN (R 4.4.2)\n##    lattice                0.22-6    2024-03-20 [2] CRAN (R 4.4.2)\n##    lazyeval               0.2.2     2019-03-15 [1] CRAN (R 4.4.2)\n##    leiden                 0.4.3.1   2023-11-17 [1] CRAN (R 4.4.2)\n##    lifecycle              1.0.4     2023-11-07 [1] CRAN (R 4.4.2)\n##    limma                  3.62.1    2024-11-03 [1] Bioconductor 3.20 (R 4.4.1)\n##    listenv                0.9.1     2024-01-29 [1] CRAN (R 4.4.2)\n##    lmtest                 0.9-40    2022-03-21 [1] CRAN (R 4.4.2)\n##    locfit                 1.5-9.10  2024-06-24 [1] CRAN (R 4.4.2)\n##    magrittr               2.0.3     2022-03-30 [1] CRAN (R 4.4.2)\n##    MASS                   7.3-61    2024-06-13 [2] CRAN (R 4.4.2)\n##    Matrix               * 1.7-1     2024-10-18 [2] CRAN (R 4.4.2)\n##    MatrixGenerics       * 1.18.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    matrixStats          * 1.4.1     2024-09-08 [1] CRAN (R 4.4.2)\n##    memoise                2.0.1     2021-11-26 [1] CRAN (R 4.4.2)\n##    metapod                1.14.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    mime                   0.12      2021-09-28 [1] CRAN (R 4.4.0)\n##    miniUI                 0.1.1.1   2018-05-18 [1] CRAN (R 4.4.2)\n##    munsell                0.5.1     2024-04-01 [1] CRAN (R 4.4.2)\n##    nlme                   3.1-166   2024-08-14 [2] CRAN (R 4.4.2)\n##    parallelly             1.41.0    2024-12-18 [1] CRAN (R 4.4.2)\n##    patchwork            * 1.3.0     2024-09-16 [1] CRAN (R 4.4.2)\n##    pbapply                1.7-2     2023-06-27 [1] CRAN (R 4.4.2)\n##    PCAtools             * 2.18.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    pheatmap             * 1.0.12    2019-01-04 [1] CRAN (R 4.4.2)\n##    pillar                 1.10.0    2024-12-17 [1] CRAN (R 4.4.2)\n##    pkgconfig              2.0.3     2019-09-22 [1] CRAN (R 4.4.2)\n##    plotly                 4.10.4    2024-01-13 [1] CRAN (R 4.4.2)\n##    plyr                   1.8.9     2023-10-02 [1] CRAN (R 4.4.2)\n##    png                    0.1-8     2022-11-29 [1] CRAN (R 4.4.0)\n##    polyclip               1.10-7    2024-07-23 [1] CRAN (R 4.4.1)\n##    progressr              0.15.1    2024-11-22 [1] CRAN (R 4.4.2)\n##    promises               1.3.2     2024-11-28 [1] CRAN (R 4.4.2)\n##    ProtGenerics           1.38.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    purrr                  1.0.2     2023-08-10 [1] CRAN (R 4.4.2)\n##    R.methodsS3            1.8.2     2022-06-13 [1] CRAN (R 4.4.0)\n##    R.oo                   1.27.0    2024-11-01 [1] CRAN (R 4.4.1)\n##    R.utils                2.12.3    2023-11-18 [1] CRAN (R 4.4.2)\n##    R6                     2.5.1     2021-08-19 [1] CRAN (R 4.4.2)\n##    RANN                   2.6.2     2024-08-25 [1] CRAN (R 4.4.2)\n##    rappdirs               0.3.3     2021-01-31 [1] CRAN (R 4.4.2)\n##    RColorBrewer           1.1-3     2022-04-03 [1] CRAN (R 4.4.0)\n##    Rcpp                   1.0.13-1  2024-11-02 [1] CRAN (R 4.4.2)\n##    RcppAnnoy              0.0.22    2024-01-23 [1] CRAN (R 4.4.2)\n##    RcppHNSW               0.6.0     2024-02-04 [1] CRAN (R 4.4.2)\n##    RCurl                  1.98-1.16 2024-07-11 [1] CRAN (R 4.4.1)\n##    remotes                2.5.0     2024-03-17 [1] CRAN (R 4.4.2)\n##    reshape2               1.4.4     2020-04-09 [1] CRAN (R 4.4.2)\n##    ResidualMatrix         1.16.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    restfulr               0.0.15    2022-06-16 [1] CRAN (R 4.4.2)\n##    reticulate             1.40.0    2024-11-15 [1] CRAN (R 4.4.2)\n##    rhdf5                  2.50.1    2024-12-09 [1] Bioconductor 3.20 (R 4.4.2)\n##  D rhdf5filters           1.18.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    Rhdf5lib               1.28.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    rjson                  0.2.23    2024-09-16 [1] CRAN (R 4.4.1)\n##    rlang                  1.1.4     2024-06-04 [1] CRAN (R 4.4.2)\n##    rmarkdown              2.29      2024-11-04 [1] CRAN (R 4.4.2)\n##    ROCR                   1.0-11    2020-05-02 [1] CRAN (R 4.4.2)\n##    Rsamtools              2.22.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    RSpectra               0.16-2    2024-07-18 [1] CRAN (R 4.4.2)\n##    RSQLite                2.3.9     2024-12-03 [1] CRAN (R 4.4.2)\n##    rstudioapi             0.17.1    2024-10-22 [1] CRAN (R 4.4.2)\n##    rsvd                   1.0.5     2021-04-16 [1] CRAN (R 4.4.2)\n##    rtracklayer            1.66.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    Rtsne                  0.17      2023-12-07 [1] CRAN (R 4.4.2)\n##    S4Arrays               1.6.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    S4Vectors            * 0.44.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    ScaledMatrix           1.14.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    scales                 1.3.0     2023-11-28 [1] CRAN (R 4.4.2)\n##    scater               * 1.34.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    scattermore            1.2       2023-06-12 [1] CRAN (R 4.4.2)\n##    scran                * 1.34.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    scRNAseq             * 2.20.0    2024-10-31 [1] Bioconductor 3.20 (R 4.4.2)\n##    sctransform            0.4.1     2023-10-19 [1] CRAN (R 4.4.2)\n##    scuttle              * 1.16.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    sessioninfo            1.2.2     2021-12-06 [1] CRAN (R 4.4.2)\n##    Seurat               * 5.1.0     2024-05-10 [1] CRAN (R 4.4.2)\n##    SeuratObject         * 5.0.2     2024-05-08 [1] CRAN (R 4.4.2)\n##    shiny                  1.10.0    2024-12-14 [1] CRAN (R 4.4.2)\n##    SingleCellExperiment * 1.28.1    2024-11-10 [1] Bioconductor 3.20 (R 4.4.1)\n##    SingleR              * 2.8.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    sp                   * 2.1-4     2024-04-30 [1] CRAN (R 4.4.2)\n##    spam                   2.11-0    2024-10-03 [1] CRAN (R 4.4.2)\n##    SparseArray            1.6.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    sparseMatrixStats      1.18.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    spatstat.data          3.1-4     2024-11-15 [1] CRAN (R 4.4.2)\n##    spatstat.explore       3.3-3     2024-10-22 [1] CRAN (R 4.4.2)\n##    spatstat.geom          3.3-4     2024-11-18 [1] CRAN (R 4.4.2)\n##    spatstat.random        3.3-2     2024-09-18 [1] CRAN (R 4.4.2)\n##    spatstat.sparse        3.1-0     2024-06-21 [1] CRAN (R 4.4.2)\n##    spatstat.univar        3.1-1     2024-11-05 [1] CRAN (R 4.4.2)\n##    spatstat.utils         3.1-1     2024-11-03 [1] CRAN (R 4.4.2)\n##    statmod                1.5.0     2023-01-06 [1] CRAN (R 4.4.2)\n##    stringi                1.8.4     2024-05-06 [1] CRAN (R 4.4.0)\n##    stringr                1.5.1     2023-11-14 [1] CRAN (R 4.4.2)\n##    SummarizedExperiment * 1.36.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    survival               3.7-0     2024-06-05 [2] CRAN (R 4.4.2)\n##    tensor                 1.5       2012-05-05 [1] CRAN (R 4.4.0)\n##    tibble                 3.2.1     2023-03-20 [1] CRAN (R 4.4.2)\n##    tidygraph              1.3.1     2024-01-30 [1] CRAN (R 4.4.2)\n##    tidyr                  1.3.1     2024-01-24 [1] CRAN (R 4.4.2)\n##    tidyselect             1.2.1     2024-03-11 [1] CRAN (R 4.4.2)\n##    tweenr                 2.0.3     2024-02-26 [1] CRAN (R 4.4.2)\n##    UCSC.utils             1.2.0     2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    uwot                   0.2.2     2024-04-21 [1] CRAN (R 4.4.2)\n##    vctrs                  0.6.5     2023-12-01 [1] CRAN (R 4.4.2)\n##    vipor                  0.4.7     2023-12-18 [1] CRAN (R 4.4.2)\n##    viridis                0.6.5     2024-01-29 [1] CRAN (R 4.4.2)\n##    viridisLite            0.4.2     2023-05-02 [1] CRAN (R 4.4.2)\n##    withr                  3.0.2     2024-10-28 [1] CRAN (R 4.4.2)\n##    xfun                   0.49      2024-10-31 [1] CRAN (R 4.4.2)\n##    XML                  * 3.99-0.17 2024-06-25 [1] CRAN (R 4.4.1)\n##    xtable                 1.8-4     2019-04-21 [1] CRAN (R 4.4.2)\n##    XVector                0.46.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    yaml                   2.3.10    2024-07-26 [1] CRAN (R 4.4.1)\n##    zlibbioc               1.52.0    2024-10-29 [1] Bioconductor 3.20 (R 4.4.1)\n##    zoo                    1.8-12    2023-04-13 [1] CRAN (R 4.4.2)\n## \n##  [1] C:/Users/chomb/AppData/Local/R/win-library/4.4\n##  [2] C:/Program Files/R/R-4.4.2/library\n## \n##  D ── DLL MD5 mismatch, broken installation.\n## \n## ──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Single-cell RNA-seq</span>"
    ]
  }
]